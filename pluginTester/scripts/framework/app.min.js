"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Created by Daniel on 9/29/2015.
 * single event handlers that enforce
 * limited lifespan event handlers that are not singletons
 */

var postMaster = {
    controlPluginAPI: null,
    widgetPluginAPI: null,
    launcherPluginAPI: null,
    servicePluginAPIs: {},
    postMessageHandler: function postMessageHandler(e) {

        if (!e.data) return;else if (_typeof(e.data) == "object") e.packet = e.data;else {
            /// parse data to once and not per pluginAPI
            try {
                e.packet = JSON.parse(e.data);
            } catch (err) {
                console.log("!! Post Master:: Ignore Invalid packet", err, e.data);
                return;
            }
        }

        postMaster._acceptRequest(e);
    },
    _acceptRequest: function _acceptRequest(e) {

        if (!e || !e.packet || !e.packet.cmd) return;

        function tryPMH(pluginAPI, e) {
            if (!pluginAPI || !pluginAPI.postMessageHandler || !e) return false;

            try {
                return pluginAPI.postMessageHandler(e);
            } catch (err) {
                console.error('postMessageHandler error:', err);
                return false;
            }
        }

        var foundHome = false;

        foundHome = tryPMH(postMaster.widgetPluginAPI, e);
        if (foundHome) return;

        if (postMaster.widgetPluginAPI != postMaster.launcherPluginAPI) foundHome = tryPMH(postMaster.launcherPluginAPI, e);
        if (foundHome) return;

        foundHome = tryPMH(postMaster.controlPluginAPI, e);
        if (foundHome) return;

        for (var p in postMaster.servicePluginAPIs) {
            foundHome = tryPMH(postMaster.servicePluginAPIs[p], e);
            if (foundHome) return;
        }

        if (!foundHome) console.warn('no home for this packet (sad face) ');
    },
    broadcast: function broadcast(packet, optionalInstanceFilter) {

        function trySendMessage(pluginAPI) {
            if (!pluginAPI) return;
            if (!optionalInstanceFilter || pluginAPI.context.instanceId == optionalInstanceFilter) pluginAPI.sendMessage(null, packet);
        }

        trySendMessage(postMaster.controlPluginAPI);

        if (postMaster.widgetPluginAPI && postMaster.widgetPluginAPI != postMaster.launcherPluginAPI) // if widget is same as launcher dont bother running twice
            trySendMessage(postMaster.widgetPluginAPI);

        if (postMaster.widgetPluginAPI == postMaster.launcherPluginAPI) // if widget == launcher then make launcher handle it
            packet.fid = postMaster.launcherPluginAPI.iFrameId;

        trySendMessage(postMaster.launcherPluginAPI);

        //broadcast to each service
        for (var p in postMaster.servicePluginAPIs) {
            trySendMessage(postMaster.servicePluginAPIs[p]);
        }
    },

    attachService: function attachService(instanceId, pluginAPI) {
        this.servicePluginAPIs[instanceId] = pluginAPI;
    },
    dettachService: function dettachService(instanceId) {
        delete this.servicePluginAPIs[instanceId];
    },

    isLauncherPluginActive: function isLauncherPluginActive() {
        return postMaster.widgetPluginAPI == null || postMaster.widgetPluginAPI == postMaster.launcherPluginAPI;
    }

};

window.addEventListener('message', postMaster.postMessageHandler, false);
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
!function (a, b, c, d) {
  "use strict";
  function e(a, b, c) {
    return setTimeout(k(a, c), b);
  }function f(a, b, c) {
    return Array.isArray(a) ? (g(a, c[b], c), !0) : !1;
  }function g(a, b, c) {
    var e;if (a) if (a.forEach) a.forEach(b, c);else if (a.length !== d) for (e = 0; e < a.length;) {
      b.call(c, a[e], e, a), e++;
    } else for (e in a) {
      a.hasOwnProperty(e) && b.call(c, a[e], e, a);
    }
  }function h(a, b, c) {
    for (var e = Object.keys(b), f = 0; f < e.length;) {
      (!c || c && a[e[f]] === d) && (a[e[f]] = b[e[f]]), f++;
    }return a;
  }function i(a, b) {
    return h(a, b, !0);
  }function j(a, b, c) {
    var d,
        e = b.prototype;d = a.prototype = Object.create(e), d.constructor = a, d._super = e, c && h(d, c);
  }function k(a, b) {
    return function () {
      return a.apply(b, arguments);
    };
  }function l(a, b) {
    return (typeof a === "undefined" ? "undefined" : _typeof(a)) == kb ? a.apply(b ? b[0] || d : d, b) : a;
  }function m(a, b) {
    return a === d ? b : a;
  }function n(a, b, c) {
    g(r(b), function (b) {
      a.addEventListener(b, c, !1);
    });
  }function o(a, b, c) {
    g(r(b), function (b) {
      a.removeEventListener(b, c, !1);
    });
  }function p(a, b) {
    for (; a;) {
      if (a == b) return !0;a = a.parentNode;
    }return !1;
  }function q(a, b) {
    return a.indexOf(b) > -1;
  }function r(a) {
    return a.trim().split(/\s+/g);
  }function s(a, b, c) {
    if (a.indexOf && !c) return a.indexOf(b);for (var d = 0; d < a.length;) {
      if (c && a[d][c] == b || !c && a[d] === b) return d;d++;
    }return -1;
  }function t(a) {
    return Array.prototype.slice.call(a, 0);
  }function u(a, b, c) {
    for (var d = [], e = [], f = 0; f < a.length;) {
      var g = b ? a[f][b] : a[f];s(e, g) < 0 && d.push(a[f]), e[f] = g, f++;
    }return c && (d = b ? d.sort(function (a, c) {
      return a[b] > c[b];
    }) : d.sort()), d;
  }function v(a, b) {
    for (var c, e, f = b[0].toUpperCase() + b.slice(1), g = 0; g < ib.length;) {
      if (c = ib[g], e = c ? c + f : b, e in a) return e;g++;
    }return d;
  }function w() {
    return ob++;
  }function x(a) {
    var b = a.ownerDocument;return b.defaultView || b.parentWindow;
  }function y(a, b) {
    var c = this;this.manager = a, this.callback = b, this.element = a.element, this.target = a.options.inputTarget, this.domHandler = function (b) {
      l(a.options.enable, [a]) && c.handler(b);
    }, this.init();
  }function z(a) {
    var b,
        c = a.options.inputClass;return new (b = c ? c : rb ? N : sb ? Q : qb ? S : M)(a, A);
  }function A(a, b, c) {
    var d = c.pointers.length,
        e = c.changedPointers.length,
        f = b & yb && d - e === 0,
        g = b & (Ab | Bb) && d - e === 0;c.isFirst = !!f, c.isFinal = !!g, f && (a.session = {}), c.eventType = b, B(a, c), a.emit("hammer.input", c), a.recognize(c), a.session.prevInput = c;
  }function B(a, b) {
    var c = a.session,
        d = b.pointers,
        e = d.length;c.firstInput || (c.firstInput = E(b)), e > 1 && !c.firstMultiple ? c.firstMultiple = E(b) : 1 === e && (c.firstMultiple = !1);var f = c.firstInput,
        g = c.firstMultiple,
        h = g ? g.center : f.center,
        i = b.center = F(d);b.timeStamp = nb(), b.deltaTime = b.timeStamp - f.timeStamp, b.angle = J(h, i), b.distance = I(h, i), C(c, b), b.offsetDirection = H(b.deltaX, b.deltaY), b.scale = g ? L(g.pointers, d) : 1, b.rotation = g ? K(g.pointers, d) : 0, D(c, b);var j = a.element;p(b.srcEvent.target, j) && (j = b.srcEvent.target), b.target = j;
  }function C(a, b) {
    var c = b.center,
        d = a.offsetDelta || {},
        e = a.prevDelta || {},
        f = a.prevInput || {};(b.eventType === yb || f.eventType === Ab) && (e = a.prevDelta = { x: f.deltaX || 0, y: f.deltaY || 0 }, d = a.offsetDelta = { x: c.x, y: c.y }), b.deltaX = e.x + (c.x - d.x), b.deltaY = e.y + (c.y - d.y);
  }function D(a, b) {
    var c,
        e,
        f,
        g,
        h = a.lastInterval || b,
        i = b.timeStamp - h.timeStamp;if (b.eventType != Bb && (i > xb || h.velocity === d)) {
      var j = h.deltaX - b.deltaX,
          k = h.deltaY - b.deltaY,
          l = G(i, j, k);e = l.x, f = l.y, c = mb(l.x) > mb(l.y) ? l.x : l.y, g = H(j, k), a.lastInterval = b;
    } else c = h.velocity, e = h.velocityX, f = h.velocityY, g = h.direction;b.velocity = c, b.velocityX = e, b.velocityY = f, b.direction = g;
  }function E(a) {
    for (var b = [], c = 0; c < a.pointers.length;) {
      b[c] = { clientX: lb(a.pointers[c].clientX), clientY: lb(a.pointers[c].clientY) }, c++;
    }return { timeStamp: nb(), pointers: b, center: F(b), deltaX: a.deltaX, deltaY: a.deltaY };
  }function F(a) {
    var b = a.length;if (1 === b) return { x: lb(a[0].clientX), y: lb(a[0].clientY) };for (var c = 0, d = 0, e = 0; b > e;) {
      c += a[e].clientX, d += a[e].clientY, e++;
    }return { x: lb(c / b), y: lb(d / b) };
  }function G(a, b, c) {
    return { x: b / a || 0, y: c / a || 0 };
  }function H(a, b) {
    return a === b ? Cb : mb(a) >= mb(b) ? a > 0 ? Db : Eb : b > 0 ? Fb : Gb;
  }function I(a, b, c) {
    c || (c = Kb);var d = b[c[0]] - a[c[0]],
        e = b[c[1]] - a[c[1]];return Math.sqrt(d * d + e * e);
  }function J(a, b, c) {
    c || (c = Kb);var d = b[c[0]] - a[c[0]],
        e = b[c[1]] - a[c[1]];return 180 * Math.atan2(e, d) / Math.PI;
  }function K(a, b) {
    return J(b[1], b[0], Lb) - J(a[1], a[0], Lb);
  }function L(a, b) {
    return I(b[0], b[1], Lb) / I(a[0], a[1], Lb);
  }function M() {
    this.evEl = Nb, this.evWin = Ob, this.allow = !0, this.pressed = !1, y.apply(this, arguments);
  }function N() {
    this.evEl = Rb, this.evWin = Sb, y.apply(this, arguments), this.store = this.manager.session.pointerEvents = [];
  }function O() {
    this.evTarget = Ub, this.evWin = Vb, this.started = !1, y.apply(this, arguments);
  }function P(a, b) {
    var c = t(a.touches),
        d = t(a.changedTouches);return b & (Ab | Bb) && (c = u(c.concat(d), "identifier", !0)), [c, d];
  }function Q() {
    this.evTarget = Xb, this.targetIds = {}, y.apply(this, arguments);
  }function R(a, b) {
    var c = t(a.touches),
        d = this.targetIds;if (b & (yb | zb) && 1 === c.length) return d[c[0].identifier] = !0, [c, c];var e,
        f,
        g = t(a.changedTouches),
        h = [],
        i = this.target;if (f = c.filter(function (a) {
      return p(a.target, i);
    }), b === yb) for (e = 0; e < f.length;) {
      d[f[e].identifier] = !0, e++;
    }for (e = 0; e < g.length;) {
      d[g[e].identifier] && h.push(g[e]), b & (Ab | Bb) && delete d[g[e].identifier], e++;
    }return h.length ? [u(f.concat(h), "identifier", !0), h] : void 0;
  }function S() {
    y.apply(this, arguments);var a = k(this.handler, this);this.touch = new Q(this.manager, a), this.mouse = new M(this.manager, a);
  }function T(a, b) {
    this.manager = a, this.set(b);
  }function U(a) {
    if (q(a, bc)) return bc;var b = q(a, cc),
        c = q(a, dc);return b && c ? cc + " " + dc : b || c ? b ? cc : dc : q(a, ac) ? ac : _b;
  }function V(a) {
    this.id = w(), this.manager = null, this.options = i(a || {}, this.defaults), this.options.enable = m(this.options.enable, !0), this.state = ec, this.simultaneous = {}, this.requireFail = [];
  }function W(a) {
    return a & jc ? "cancel" : a & hc ? "end" : a & gc ? "move" : a & fc ? "start" : "";
  }function X(a) {
    return a == Gb ? "down" : a == Fb ? "up" : a == Db ? "left" : a == Eb ? "right" : "";
  }function Y(a, b) {
    var c = b.manager;return c ? c.get(a) : a;
  }function Z() {
    V.apply(this, arguments);
  }function $() {
    Z.apply(this, arguments), this.pX = null, this.pY = null;
  }function _() {
    Z.apply(this, arguments);
  }function ab() {
    V.apply(this, arguments), this._timer = null, this._input = null;
  }function bb() {
    Z.apply(this, arguments);
  }function cb() {
    Z.apply(this, arguments);
  }function db() {
    V.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0;
  }function eb(a, b) {
    return b = b || {}, b.recognizers = m(b.recognizers, eb.defaults.preset), new fb(a, b);
  }function fb(a, b) {
    b = b || {}, this.options = i(b, eb.defaults), this.options.inputTarget = this.options.inputTarget || a, this.handlers = {}, this.session = {}, this.recognizers = [], this.element = a, this.input = z(this), this.touchAction = new T(this, this.options.touchAction), gb(this, !0), g(b.recognizers, function (a) {
      var b = this.add(new a[0](a[1]));a[2] && b.recognizeWith(a[2]), a[3] && b.requireFailure(a[3]);
    }, this);
  }function gb(a, b) {
    var c = a.element;g(a.options.cssProps, function (a, d) {
      c.style[v(c.style, d)] = b ? a : "";
    });
  }function hb(a, c) {
    var d = b.createEvent("Event");d.initEvent(a, !0, !0), d.gesture = c, c.target.dispatchEvent(d);
  }var ib = ["", "webkit", "moz", "MS", "ms", "o"],
      jb = b.createElement("div"),
      kb = "function",
      lb = Math.round,
      mb = Math.abs,
      nb = Date.now,
      ob = 1,
      pb = /mobile|tablet|ip(ad|hone|od)|android/i,
      qb = "ontouchstart" in a,
      rb = v(a, "PointerEvent") !== d,
      sb = qb && pb.test(navigator.userAgent),
      tb = "touch",
      ub = "pen",
      vb = "mouse",
      wb = "kinect",
      xb = 25,
      yb = 1,
      zb = 2,
      Ab = 4,
      Bb = 8,
      Cb = 1,
      Db = 2,
      Eb = 4,
      Fb = 8,
      Gb = 16,
      Hb = Db | Eb,
      Ib = Fb | Gb,
      Jb = Hb | Ib,
      Kb = ["x", "y"],
      Lb = ["clientX", "clientY"];y.prototype = { handler: function handler() {}, init: function init() {
      this.evEl && n(this.element, this.evEl, this.domHandler), this.evTarget && n(this.target, this.evTarget, this.domHandler), this.evWin && n(x(this.element), this.evWin, this.domHandler);
    }, destroy: function destroy() {
      this.evEl && o(this.element, this.evEl, this.domHandler), this.evTarget && o(this.target, this.evTarget, this.domHandler), this.evWin && o(x(this.element), this.evWin, this.domHandler);
    } };var Mb = { mousedown: yb, mousemove: zb, mouseup: Ab },
      Nb = "mousedown",
      Ob = "mousemove mouseup";j(M, y, { handler: function handler(a) {
      var b = Mb[a.type];b & yb && 0 === a.button && (this.pressed = !0), b & zb && 1 !== a.which && (b = Ab), this.pressed && this.allow && (b & Ab && (this.pressed = !1), this.callback(this.manager, b, { pointers: [a], changedPointers: [a], pointerType: vb, srcEvent: a }));
    } });var Pb = { pointerdown: yb, pointermove: zb, pointerup: Ab, pointercancel: Bb, pointerout: Bb },
      Qb = { 2: tb, 3: ub, 4: vb, 5: wb },
      Rb = "pointerdown",
      Sb = "pointermove pointerup pointercancel";a.MSPointerEvent && (Rb = "MSPointerDown", Sb = "MSPointerMove MSPointerUp MSPointerCancel"), j(N, y, { handler: function handler(a) {
      var b = this.store,
          c = !1,
          d = a.type.toLowerCase().replace("ms", ""),
          e = Pb[d],
          f = Qb[a.pointerType] || a.pointerType,
          g = f == tb,
          h = s(b, a.pointerId, "pointerId");e & yb && (0 === a.button || g) ? 0 > h && (b.push(a), h = b.length - 1) : e & (Ab | Bb) && (c = !0), 0 > h || (b[h] = a, this.callback(this.manager, e, { pointers: b, changedPointers: [a], pointerType: f, srcEvent: a }), c && b.splice(h, 1));
    } });var Tb = { touchstart: yb, touchmove: zb, touchend: Ab, touchcancel: Bb },
      Ub = "touchstart",
      Vb = "touchstart touchmove touchend touchcancel";j(O, y, { handler: function handler(a) {
      var b = Tb[a.type];if (b === yb && (this.started = !0), this.started) {
        var c = P.call(this, a, b);b & (Ab | Bb) && c[0].length - c[1].length === 0 && (this.started = !1), this.callback(this.manager, b, { pointers: c[0], changedPointers: c[1], pointerType: tb, srcEvent: a });
      }
    } });var Wb = { touchstart: yb, touchmove: zb, touchend: Ab, touchcancel: Bb },
      Xb = "touchstart touchmove touchend touchcancel";j(Q, y, { handler: function handler(a) {
      var b = Wb[a.type],
          c = R.call(this, a, b);c && this.callback(this.manager, b, { pointers: c[0], changedPointers: c[1], pointerType: tb, srcEvent: a });
    } }), j(S, y, { handler: function handler(a, b, c) {
      var d = c.pointerType == tb,
          e = c.pointerType == vb;if (d) this.mouse.allow = !1;else if (e && !this.mouse.allow) return;b & (Ab | Bb) && (this.mouse.allow = !0), this.callback(a, b, c);
    }, destroy: function destroy() {
      this.touch.destroy(), this.mouse.destroy();
    } });var Yb = v(jb.style, "touchAction"),
      Zb = Yb !== d,
      $b = "compute",
      _b = "auto",
      ac = "manipulation",
      bc = "none",
      cc = "pan-x",
      dc = "pan-y";T.prototype = { set: function set(a) {
      a == $b && (a = this.compute()), Zb && (this.manager.element.style[Yb] = a), this.actions = a.toLowerCase().trim();
    }, update: function update() {
      this.set(this.manager.options.touchAction);
    }, compute: function compute() {
      var a = [];return g(this.manager.recognizers, function (b) {
        l(b.options.enable, [b]) && (a = a.concat(b.getTouchAction()));
      }), U(a.join(" "));
    }, preventDefaults: function preventDefaults(a) {
      if (!Zb) {
        var b = a.srcEvent,
            c = a.offsetDirection;if (this.manager.session.prevented) return void b.preventDefault();var d = this.actions,
            e = q(d, bc),
            f = q(d, dc),
            g = q(d, cc);return e || f && c & Hb || g && c & Ib ? this.preventSrc(b) : void 0;
      }
    }, preventSrc: function preventSrc(a) {
      this.manager.session.prevented = !0, a.preventDefault();
    } };var ec = 1,
      fc = 2,
      gc = 4,
      hc = 8,
      ic = hc,
      jc = 16,
      kc = 32;V.prototype = { defaults: {}, set: function set(a) {
      return h(this.options, a), this.manager && this.manager.touchAction.update(), this;
    }, recognizeWith: function recognizeWith(a) {
      if (f(a, "recognizeWith", this)) return this;var b = this.simultaneous;return a = Y(a, this), b[a.id] || (b[a.id] = a, a.recognizeWith(this)), this;
    }, dropRecognizeWith: function dropRecognizeWith(a) {
      return f(a, "dropRecognizeWith", this) ? this : (a = Y(a, this), delete this.simultaneous[a.id], this);
    }, requireFailure: function requireFailure(a) {
      if (f(a, "requireFailure", this)) return this;var b = this.requireFail;return a = Y(a, this), -1 === s(b, a) && (b.push(a), a.requireFailure(this)), this;
    }, dropRequireFailure: function dropRequireFailure(a) {
      if (f(a, "dropRequireFailure", this)) return this;a = Y(a, this);var b = s(this.requireFail, a);return b > -1 && this.requireFail.splice(b, 1), this;
    }, hasRequireFailures: function hasRequireFailures() {
      return this.requireFail.length > 0;
    }, canRecognizeWith: function canRecognizeWith(a) {
      return !!this.simultaneous[a.id];
    }, emit: function emit(a) {
      function b(b) {
        c.manager.emit(c.options.event + (b ? W(d) : ""), a);
      }var c = this,
          d = this.state;hc > d && b(!0), b(), d >= hc && b(!0);
    }, tryEmit: function tryEmit(a) {
      return this.canEmit() ? this.emit(a) : void (this.state = kc);
    }, canEmit: function canEmit() {
      for (var a = 0; a < this.requireFail.length;) {
        if (!(this.requireFail[a].state & (kc | ec))) return !1;a++;
      }return !0;
    }, recognize: function recognize(a) {
      var b = h({}, a);return l(this.options.enable, [this, b]) ? (this.state & (ic | jc | kc) && (this.state = ec), this.state = this.process(b), void (this.state & (fc | gc | hc | jc) && this.tryEmit(b))) : (this.reset(), void (this.state = kc));
    }, process: function process() {}, getTouchAction: function getTouchAction() {}, reset: function reset() {} }, j(Z, V, { defaults: { pointers: 1 }, attrTest: function attrTest(a) {
      var b = this.options.pointers;return 0 === b || a.pointers.length === b;
    }, process: function process(a) {
      var b = this.state,
          c = a.eventType,
          d = b & (fc | gc),
          e = this.attrTest(a);return d && (c & Bb || !e) ? b | jc : d || e ? c & Ab ? b | hc : b & fc ? b | gc : fc : kc;
    } }), j($, Z, { defaults: { event: "pan", threshold: 10, pointers: 1, direction: Jb }, getTouchAction: function getTouchAction() {
      var a = this.options.direction,
          b = [];return a & Hb && b.push(dc), a & Ib && b.push(cc), b;
    }, directionTest: function directionTest(a) {
      var b = this.options,
          c = !0,
          d = a.distance,
          e = a.direction,
          f = a.deltaX,
          g = a.deltaY;return e & b.direction || (b.direction & Hb ? (e = 0 === f ? Cb : 0 > f ? Db : Eb, c = f != this.pX, d = Math.abs(a.deltaX)) : (e = 0 === g ? Cb : 0 > g ? Fb : Gb, c = g != this.pY, d = Math.abs(a.deltaY))), a.direction = e, c && d > b.threshold && e & b.direction;
    }, attrTest: function attrTest(a) {
      return Z.prototype.attrTest.call(this, a) && (this.state & fc || !(this.state & fc) && this.directionTest(a));
    }, emit: function emit(a) {
      this.pX = a.deltaX, this.pY = a.deltaY;var b = X(a.direction);b && this.manager.emit(this.options.event + b, a), this._super.emit.call(this, a);
    } }), j(_, Z, { defaults: { event: "pinch", threshold: 0, pointers: 2 }, getTouchAction: function getTouchAction() {
      return [bc];
    }, attrTest: function attrTest(a) {
      return this._super.attrTest.call(this, a) && (Math.abs(a.scale - 1) > this.options.threshold || this.state & fc);
    }, emit: function emit(a) {
      if (this._super.emit.call(this, a), 1 !== a.scale) {
        var b = a.scale < 1 ? "in" : "out";this.manager.emit(this.options.event + b, a);
      }
    } }), j(ab, V, { defaults: { event: "press", pointers: 1, time: 500, threshold: 5 }, getTouchAction: function getTouchAction() {
      return [_b];
    }, process: function process(a) {
      var b = this.options,
          c = a.pointers.length === b.pointers,
          d = a.distance < b.threshold,
          f = a.deltaTime > b.time;if (this._input = a, !d || !c || a.eventType & (Ab | Bb) && !f) this.reset();else if (a.eventType & yb) this.reset(), this._timer = e(function () {
        this.state = ic, this.tryEmit();
      }, b.time, this);else if (a.eventType & Ab) return ic;return kc;
    }, reset: function reset() {
      clearTimeout(this._timer);
    }, emit: function emit(a) {
      this.state === ic && (a && a.eventType & Ab ? this.manager.emit(this.options.event + "up", a) : (this._input.timeStamp = nb(), this.manager.emit(this.options.event, this._input)));
    } }), j(bb, Z, { defaults: { event: "rotate", threshold: 0, pointers: 2 }, getTouchAction: function getTouchAction() {
      return [bc];
    }, attrTest: function attrTest(a) {
      return this._super.attrTest.call(this, a) && (Math.abs(a.rotation) > this.options.threshold || this.state & fc);
    } }), j(cb, Z, { defaults: { event: "swipe", threshold: 10, velocity: .65, direction: Hb | Ib, pointers: 1 }, getTouchAction: function getTouchAction() {
      return $.prototype.getTouchAction.call(this);
    }, attrTest: function attrTest(a) {
      var b,
          c = this.options.direction;return c & (Hb | Ib) ? b = a.velocity : c & Hb ? b = a.velocityX : c & Ib && (b = a.velocityY), this._super.attrTest.call(this, a) && c & a.direction && a.distance > this.options.threshold && mb(b) > this.options.velocity && a.eventType & Ab;
    }, emit: function emit(a) {
      var b = X(a.direction);b && this.manager.emit(this.options.event + b, a), this.manager.emit(this.options.event, a);
    } }), j(db, V, { defaults: { event: "tap", pointers: 1, taps: 1, interval: 300, time: 250, threshold: 2, posThreshold: 10 }, getTouchAction: function getTouchAction() {
      return [ac];
    }, process: function process(a) {
      var b = this.options,
          c = a.pointers.length === b.pointers,
          d = a.distance < b.threshold,
          f = a.deltaTime < b.time;if (this.reset(), a.eventType & yb && 0 === this.count) return this.failTimeout();if (d && f && c) {
        if (a.eventType != Ab) return this.failTimeout();var g = this.pTime ? a.timeStamp - this.pTime < b.interval : !0,
            h = !this.pCenter || I(this.pCenter, a.center) < b.posThreshold;this.pTime = a.timeStamp, this.pCenter = a.center, h && g ? this.count += 1 : this.count = 1, this._input = a;var i = this.count % b.taps;if (0 === i) return this.hasRequireFailures() ? (this._timer = e(function () {
          this.state = ic, this.tryEmit();
        }, b.interval, this), fc) : ic;
      }return kc;
    }, failTimeout: function failTimeout() {
      return this._timer = e(function () {
        this.state = kc;
      }, this.options.interval, this), kc;
    }, reset: function reset() {
      clearTimeout(this._timer);
    }, emit: function emit() {
      this.state == ic && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));
    } }), eb.VERSION = "2.0.4", eb.defaults = { domEvents: !1, touchAction: $b, enable: !0, inputTarget: null, inputClass: null, preset: [[bb, { enable: !1 }], [_, { enable: !1 }, ["rotate"]], [cb, { direction: Hb }], [$, { direction: Hb }, ["swipe"]], [db], [db, { event: "doubletap", taps: 2 }, ["tap"]], [ab]], cssProps: { userSelect: "none", touchSelect: "none", touchCallout: "none", contentZooming: "none", userDrag: "none", tapHighlightColor: "rgba(0,0,0,0)" } };var lc = 1,
      mc = 2;fb.prototype = { set: function set(a) {
      return h(this.options, a), a.touchAction && this.touchAction.update(), a.inputTarget && (this.input.destroy(), this.input.target = a.inputTarget, this.input.init()), this;
    }, stop: function stop(a) {
      this.session.stopped = a ? mc : lc;
    }, recognize: function recognize(a) {
      var b = this.session;if (!b.stopped) {
        this.touchAction.preventDefaults(a);var c,
            d = this.recognizers,
            e = b.curRecognizer;(!e || e && e.state & ic) && (e = b.curRecognizer = null);for (var f = 0; f < d.length;) {
          c = d[f], b.stopped === mc || e && c != e && !c.canRecognizeWith(e) ? c.reset() : c.recognize(a), !e && c.state & (fc | gc | hc) && (e = b.curRecognizer = c), f++;
        }
      }
    }, get: function get(a) {
      if (a instanceof V) return a;for (var b = this.recognizers, c = 0; c < b.length; c++) {
        if (b[c].options.event == a) return b[c];
      }return null;
    }, add: function add(a) {
      if (f(a, "add", this)) return this;var b = this.get(a.options.event);return b && this.remove(b), this.recognizers.push(a), a.manager = this, this.touchAction.update(), a;
    }, remove: function remove(a) {
      if (f(a, "remove", this)) return this;var b = this.recognizers;return a = this.get(a), b.splice(s(b, a), 1), this.touchAction.update(), this;
    }, on: function on(a, b) {
      var c = this.handlers;return g(r(a), function (a) {
        c[a] = c[a] || [], c[a].push(b);
      }), this;
    }, off: function off(a, b) {
      var c = this.handlers;return g(r(a), function (a) {
        b ? c[a].splice(s(c[a], b), 1) : delete c[a];
      }), this;
    }, emit: function emit(a, b) {
      this.options.domEvents && hb(a, b);var c = this.handlers[a] && this.handlers[a].slice();if (c && c.length) {
        b.type = a, b.preventDefault = function () {
          b.srcEvent.preventDefault();
        };for (var d = 0; d < c.length;) {
          c[d](b), d++;
        }
      }
    }, destroy: function destroy() {
      this.element && gb(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;
    } }, h(eb, { INPUT_START: yb, INPUT_MOVE: zb, INPUT_END: Ab, INPUT_CANCEL: Bb, STATE_POSSIBLE: ec, STATE_BEGAN: fc, STATE_CHANGED: gc, STATE_ENDED: hc, STATE_RECOGNIZED: ic, STATE_CANCELLED: jc, STATE_FAILED: kc, DIRECTION_NONE: Cb, DIRECTION_LEFT: Db, DIRECTION_RIGHT: Eb, DIRECTION_UP: Fb, DIRECTION_DOWN: Gb, DIRECTION_HORIZONTAL: Hb, DIRECTION_VERTICAL: Ib, DIRECTION_ALL: Jb, Manager: fb, Input: y, TouchAction: T, TouchInput: Q, MouseInput: M, PointerEventInput: N, TouchMouseInput: S, SingleTouchInput: O, Recognizer: V, AttrRecognizer: Z, Tap: db, Pan: $, Swipe: cb, Pinch: _, Rotate: bb, Press: ab, on: n, off: o, each: g, merge: i, extend: h, inherit: j, bindFn: k, prefixed: v }), (typeof define === "undefined" ? "undefined" : _typeof(define)) == kb && define.amd ? define(function () {
    return eb;
  }) : "undefined" != typeof module && module.exports ? module.exports = eb : a[c] = eb;
}(window, document, "Hammer");
'use strict';

var WebPullToRefresh = function () {
	'use strict';

	/**
  * Hold all of the default parameters for the module
  * @type {object}
  */

	var defaults = {
		// ID of the element holding pannable content area
		contentEl: 'content',

		// ID of the element holding pull to refresh loading area
		ptrEl: 'ptr',

		// Number of pixels of panning until refresh 
		distanceToRefresh: 70,

		// Pointer to function that does the loading and returns a promise
		loadingFunction: false,

		// Dragging resistance level
		resistance: 2.5
	};

	/**
  * Hold all of the merged parameter and default module options
  * @type {object}
  */
	var options = {};

	/**
  * Pan event parameters
  * @type {object}
  */
	var pan = {
		enabled: false,
		distance: 0,
		startingPositionY: 0
	};

	/**
  * Easy shortener for handling adding and removing body classes.
  */
	var bodyClass = document.body.classList;

	/**
  * Initialize pull to refresh, hammer, and bind pan events.
  * 
  * @param {object=} params - Setup parameters for pull to refresh
  */
	var init = function init(params) {
		params = params || {};
		options = {
			contentEl: params.contentEl || document.getElementById(defaults.contentEl),
			ptrEl: params.ptrEl || document.getElementById(defaults.ptrEl),
			distanceToRefresh: params.distanceToRefresh || defaults.distanceToRefresh,
			loadingFunction: params.loadingFunction || defaults.loadingFunction,
			resistance: params.resistance || defaults.resistance
		};

		if (!options.contentEl || !options.ptrEl) {
			return false;
		}

		var h = new Hammer(options.contentEl);

		h.get('pan').set({ direction: Hammer.DIRECTION_VERTICAL });

		h.on('panstart', _panStart);
		h.on('pandown', _panDown);
		h.on('panup', _panUp);
		h.on('panend', _panEnd);
	};

	var disable = function disable() {
		if (options && options.contentEl) {
			var h = new Hammer(options.contentEl);
			if (h) h.get('pan').set({ enable: false });
		}
	};

	var enable = function enable() {
		if (options && options.contentEl) {
			var h = new Hammer(options.contentEl);
			if (h) h.get('pan').set({ enable: true });
		}
	};

	/**
  * Determine whether pan events should apply based on scroll position on panstart
  * 
  * @param {object} e - Event object
  */
	var _panStart = function _panStart(e) {
		pan.startingPositionY = document.body.scrollTop;

		if (pan.startingPositionY === 0) {
			pan.enabled = true;
		}
	};

	/**
  * Handle element on screen movement when the pandown events is firing.
  * 
  * @param {object} e - Event object
  */
	var _panDown = function _panDown(e) {
		if (!pan.enabled) {
			return;
		}

		e.preventDefault();
		pan.distance = e.distance / options.resistance;

		_setContentPan();
		_setBodyClass();
	};

	/**
  * Handle element on screen movement when the pandown events is firing.
  * 
  * @param {object} e - Event object
  */
	var _panUp = function _panUp(e) {
		if (!pan.enabled || pan.distance === 0) {
			return;
		}

		e.preventDefault();

		if (pan.distance < e.distance / options.resistance) {
			pan.distance = 0;
		} else {
			pan.distance = e.distance / options.resistance;
		}

		_setContentPan();
		_setBodyClass();
	};

	/**
  * Set the CSS transform on the content element to move it on the screen.
  */
	var _setContentPan = function _setContentPan() {
		// Use transforms to smoothly animate elements on desktop and mobile devices
		options.contentEl.style.transform = options.contentEl.style.webkitTransform = 'translate3d( 0, ' + pan.distance + 'px, 0 )';
		options.ptrEl.style.transform = options.ptrEl.style.webkitTransform = 'translate3d( 0, ' + (pan.distance - options.ptrEl.offsetHeight) + 'px, 0 )';
	};

	/**
  * Set/remove the loading body class to show or hide the loading indicator after pull down.
  */
	var _setBodyClass = function _setBodyClass() {
		if (pan.distance > options.distanceToRefresh) {
			bodyClass.add('ptr-refresh');
		} else {
			bodyClass.remove('ptr-refresh');
		}
	};

	/**
  * Determine how to animate and position elements when the panend event fires.
  * 
  * @param {object} e - Event object
  */
	var _panEnd = function _panEnd(e) {
		if (!pan.enabled) {
			return;
		}

		e.preventDefault();

		options.contentEl.style.transform = options.contentEl.style.webkitTransform = '';
		options.ptrEl.style.transform = options.ptrEl.style.webkitTransform = '';

		if (document.body.classList.contains('ptr-refresh')) {
			_doLoading();
		} else {
			_doReset();
		}

		pan.distance = 0;
		pan.enabled = false;
	};

	/**
  * Position content and refresh elements to show that loading is taking place.
  */
	var _doLoading = function _doLoading() {
		bodyClass.add('ptr-loading');

		// If no valid loading function exists, just reset elements
		if (!options.loadingFunction) {
			return _doReset();
		}

		// The loading function should return a promise
		var loadingPromise = options.loadingFunction();

		// For UX continuity, make sure we show loading for at least one second before resetting
		setTimeout(function () {
			// Once actual loading is complete, reset pull to refresh
			loadingPromise.then(_doReset);
		}, 1000);
	};

	/**
  * Reset all elements to their starting positions before any paning took place.
  */
	var _doReset = function _doReset() {
		bodyClass.remove('ptr-loading');
		bodyClass.remove('ptr-refresh');
		bodyClass.add('ptr-reset');

		var bodyClassRemove = function bodyClassRemove() {
			bodyClass.remove('ptr-reset');
			document.body.removeEventListener('transitionend', bodyClassRemove, false);
		};

		document.body.addEventListener('transitionend', bodyClassRemove, false);
	};

	return {
		init: init,
		disable: disable,
		enable: enable
	};
}();
'use strict';

(function () {
    console.log('httpClient is loading');
    function CustomPromise(callback) {
        this.promise = new Promise(callback);
        this.promise.success = function (callback) {
            this.then(callback);
            return this;
        };
        this.promise.error = function (callback) {
            this.then(null, callback);
            return this;
        };
        return this.promise;
    }

    function httpClient() {}
    httpClient.get = function (url, config) {
        return httpClient.request('GET', url, undefined, config);
    };
    httpClient.post = function (url, data, config) {
        return httpClient.request('POST', url, data);
    };
    httpClient.put = function (url, data, config) {
        return httpClient.request('PUT', url, data);
    };
    httpClient.jsonp = function (url, data, config) {
        var req = {
            url: url,
            data: data,
            config: config
        };
        throw new Error('jsonp not ready, req: ' + JSON.stringify(req));
    };

    httpClient.request = function (method, url, data, config) {
        console.log('httpClient create request for url: ', url, ' using method: ', method);
        return new CustomPromise(function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.onload = function () {
                console.log('httpClient read response for url: ', url, ' using method: ', method);
                var options = {
                    status: xhr.status,
                    statusText: xhr.statusText
                };
                var body = 'response' in xhr ? xhr.response : xhr.responseText;
                resolve(body ? JSON.parse(body) : null);
            };
            xhr.onerror = function () {
                console.log('httpClient failed for url: ', url, ' using method: ', method);
                reject(new TypeError('Network request failed'));
            };
            xhr.ontimeout = function () {
                console.log('httpClient timed out for url: ', url, ' using method: ', method);
                reject(new TypeError('Network request failed'));
            };

            console.log('httpClient requesting for url: ', url, ' using method: ', method);
            xhr.open(method, url, true);
            xhr.send(data);
        });
    };

    window.httpClient = httpClient;
})();
"use strict";

/*Utility class for any random function we may neeed in the future  */

var bfUtils = {
    get deviceOnline() {
        if (typeof navigator != "undefined") {
            if (navigator.connection && navigator.connection.type) return navigator.connection.type != "none";else if (typeof navigator.onLine != "undefined") {
                return navigator.onLine;
            } else {
                return true;
            }
        } else return true;
    },
    get isMobileDevice() {
        return window.location.protocol.indexOf('http') < 0;
    },
    get isAndroid() {
        return window.location.protocol.indexOf('http') < 0 && typeof device != "undefined" && device.platform == "Android";
    },
    get isIOS() {
        return window.location.protocol.indexOf('http') < 0 && typeof device != "undefined" && device.platform == "iOS";
    },
    get isPwaAndroid() {
        var isMatch = navigator.userAgent.match(/Android/i) ? true : false;

        return isMatch;
    },
    get isPwaiOS() {
        return "standalone" in window.navigator && !window.navigator.standalone;
    },
    get isAppHtml5Version() {
        return window.self == window.top;
    },
    get isEmulatorCP() {
        return window.top && window.top != window && window.location.protocol.indexOf('http') == 0;
    },
    tryParseJSON: function tryParseJSON(str) {
        try {
            return JSON.parse(str);
        } catch (e) {
            console.error('Cannot parse data :: ' + str, e.message, e.stack);
            return undefined;
        };
    },
    get http() {
        if (window.$http) {
            return window.$http;
        } else {
            return window.httpClient;
        }
    }
};
/**
 * Created by Rami on 03/08/2016.
 */
"use strict";

var userTags = {
    get isUserTaggingEnabled() {
        return window.appContext && window.appContext.currentApp && window.appContext.currentApp.config && window.appContext.currentApp.config.userTagging && window.appContext.currentApp.config.userTagging != "hidden" && window.appContext.currentApp.config.userTagging != "disabled";
    },
    init: function init() {
        setTimeout(function () {
            if (userTags.isUserTaggingEnabled) userTags.refreshUserTags();
        }, 1000);
    },
    refreshUserTags: function refreshUserTags() {
        authAPI.getCurrentUser(function (err, user) {
            if (err) {
                console.error(err);
                callback(err, null);
                return;
            }

            if (!user) return;

            var params = {
                skip: 0,
                limit: 1
            };
            params.name = [];
            params.name.push(user.email);

            bfUtils.http.post(window.siteConfig.endPoints.appHost + '/api/userTagging/userSearch/' + window.appContext.currentApp.appId + '/', params).success(function (result) {
                if (result.users[0]) {
                    user.tags = result.users[0].tags;
                    authAPI._setCurrentUser(user);
                }
            }).error(function (err) {
                console.error(err);
            });
        });
    },
    checkPluginAccessSettings: function checkPluginAccessSettings(pluginInstance, callback) {
        var accessSettings = pluginInstance.accessSettings;

        //skip the tag permission settings if the user on EmulatorCP
        if (!bfUtils.isEmulatorCP && pluginInstance.requiresLogin) {
            authAPI.getCurrentUser(function (err, user) {
                if (err) {
                    console.error(err);
                    callback(err, null);
                    return;
                }
                if (user) {
                    if (!userTags.isUserTaggingEnabled || window.appContext.currentApp.config.advancedPluginAccessSettings != 'enabled') {
                        callback(null, true);
                        return;
                    }

                    if (!accessSettings) {
                        callback(null, true);
                        return;
                    }

                    if (!accessSettings.requiresTags) {
                        callback(null, true);
                        return;
                    }

                    if (!accessSettings.requiredTags || accessSettings.requiredTags.length == 0) {
                        callback(null, true);
                        return;
                    }

                    if (accessSettings.giveAccessWhen) {
                        if (user.tags && user.tags[window.appContext.currentApp.appId] && user.tags[window.appContext.currentApp.appId].length > 0) {

                            var tags = user.tags[window.appContext.currentApp.appId];

                            if (accessSettings.giveAccessWhen == 'matchAllTags') {
                                for (var i = 0; i < accessSettings.requiredTags.length; i++) {
                                    var matched = false;
                                    for (var j = 0; j < tags.length; j++) {
                                        if (tags[j].tagName == accessSettings.requiredTags[i].name && accessSettings.requiredTags[i].appliedCount <= tags[j].appliedCount) {
                                            matched = true;
                                            break;
                                        }
                                    }

                                    if (!matched) {
                                        callback(null, false);
                                        return;
                                    }
                                }
                                callback(null, true);
                                /*If all the required tags have been checked and none of them doesn't match the criteria then return true*/
                            } else {
                                for (var i = 0; i < accessSettings.requiredTags.length; i++) {
                                    for (var j = 0; j < tags.length; j++) {
                                        if (tags[j].tagName == accessSettings.requiredTags[i].name && accessSettings.requiredTags[i].appliedCount <= tags[j].appliedCount) {
                                            callback(null, true);
                                            return;
                                        }
                                    }
                                }
                                callback(null, false);
                                /*If all the required tags have been checked and none of them match the criteria then return false*/
                            }
                        } else {
                            callback(null, false);
                        }
                    } else callback(null, false);
                } else {
                    callback(null, false);
                }
            });
        } else {
            callback(null, true);
        }
    },
    setBehavioralTags: function setBehavioralTags(instanceId) {
        if (bfUtils.isMobileDevice && bfUtils.deviceOnline && userTags.isUserTaggingEnabled) {
            authAPI.getCurrentUser(null, function (err, user) {
                if (err) console.log(err);else if (user) {
                    bfUtils.http.post(window.siteConfig.endPoints.appHost + "/api/userTagging/app/" + window.appContext.currentApp.appId + "/user/assignBehavioralTag", {
                        instanceId: instanceId,
                        userToken: user.userToken
                    }).success(function (requiresHardBuild) {}).error(function (err) {
                        console.log(err);
                    });
                }
            });
        }
    }
};

userTags.init();
"use strict";
/**
 * Created by Daniel on 3/30/2015.
 * only allow reads without secure api key
 * cache data here so that we dont hit the server for the same info over and over
 */

function RemoteDatastore(appId, pluginId, instanceId, liveMode, dataStoreUrl) {
    this.appId = appId;
    this.pluginId = pluginId;
    this.instanceId = instanceId;
    this.liveMode = liveMode;
    this.dataStoreUrl = dataStoreUrl;
}

RemoteDatastore.prototype = {
    createReadUrl: function createReadUrl(tag, id, withDynamicData) {

        var url = this.dataStoreUrl + "/plugin/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + this.liveMode + "/" + id;
        if (withDynamicData) {
            url += "?withDynamicData=true";
        }
        return url;
    },
    createSearchUrl: function createSearchUrl(tag) {
        return this.dataStoreUrl + "/plugin/search/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + this.liveMode + "/";
    },
    createWriteUrl: function createWriteUrl(tag) {
        return this.dataStoreUrl + "/plugin/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/";
    },
    createCloneUrl: function createCloneUrl(tag) {
        return this.dataStoreUrl + "/app/" + this.appId + "/plugin/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/clone/";
    },
    createSearchAndUpdateUrl: function createSearchAndUpdateUrl(tag) {
        return this.dataStoreUrl + "/plugin/searchAndUpdate/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/";
    },
    createDeleteUrl: function createDeleteUrl(tag, id) {
        return this.dataStoreUrl + "/plugin/delete/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + id;
    },
    createSaveUrl: function createSaveUrl(tag) {
        return this.dataStoreUrl + "/plugin/save/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/";
    },
    createBulkInsertUrl: function createBulkInsertUrl(tag) {
        return this.dataStoreUrl + "/plugin/bulkInsert/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/";
    },
    createPublishUrl: function createPublishUrl() {
        return this.dataStoreUrl + "/publish/" + this.appId;
    },
    createServicesUrl: function createServicesUrl() {
        return this.dataStoreUrl + "/app/" + this.appId + "/services/" + this.liveMode;
    },
    createDeletePluginInstanceUrl: function createDeletePluginInstanceUrl(id) {
        return this.dataStoreUrl + "/plugin/deletePluginInstance/" + this.appId + "/" + id;
    },
    resolveTag: function resolveTag(tag) {
        if (tag == null || tag == undefined || tag == "") return 'primary';
        return tag;
    },
    _httpGet: function _httpGet(url, context, callback) {
        if (typeof context == 'function' && !callback) {
            callback = context;
            context = this;
        }

        if (bfUtils.http) {
            bfUtils.http.get(url).success(function (data) {
                callback.apply(context, [null, data]);
            }).error(function (data, status, headers, config) {
                var errMsg = 'datastore GET Error with URL: ' + config.url;
                callback(errMsg);
                console.error('datastore GET Error: ' + config.url, status);
            });
        } else {
            callback('datastore GET Error:bfUtils.http is undefined. Try again later.');
        }
    },
    _httpPost: function _httpPost(url, data, callback) {

        bfUtils.http.post(url, data).success(function (result) {
            callback(null, result);
        }).error(function (data, status, headers, config) {
            var errMsg = 'datastore POST Error with URL: ' + config.url;
            callback(errMsg);
            console.error('datastore POST Result: ', status, config.url);
        });
    },
    _httpPut: function _httpPut(url, data, callback) {
        bfUtils.http.put(url, data).success(function (result) {
            callback(null, result);
        }).error(function (data, status, headers, config) {
            var errMsg = 'datastore PUT Error with URL: ' + config.url;
            callback(errMsg);
            console.error('datastore PUT Result: ', status, config.url);
        });
    },
    get: function get(id, tag, data, withDynamicData, callback) {
        this._httpGet(this.createReadUrl(tag, id, withDynamicData), data, callback);
        return this;
    },
    save: function save(tag, data, callback) {
        this._httpPost(this.createSaveUrl(tag), data, callback);
        return this;
    },
    insert: function insert(tag, data, callback) {
        this._httpPost(this.createWriteUrl(tag), data, callback);
        return this;
    },
    clone: function clone(tag, data, callback) {
        this._httpPost(this.createCloneUrl(tag), data, callback);
        return this;
    },
    bulkInsert: function bulkInsert(tag, data, callback) {
        this._httpPost(this.createBulkInsertUrl(tag), data, callback);
        return this;
    },
    update: function update(tag, data, callback) {
        this._httpPut(this.createWriteUrl(tag), data, callback);
        return this;
    },
    searchAndUpdate: function searchAndUpdate(tag, data, callback) {
        this._httpPost(this.createSearchAndUpdateUrl(tag), data, callback);
        return this;
    },
    delete: function _delete(tag, id, data, callback) {
        this._httpPost(this.createDeleteUrl(tag, id), data, callback);
        return this;
    },
    search: function search(tag, options, data, callback) {
        this._httpPost(this.createSearchUrl(tag), data, callback);
        return this;
    },
    publish: function publish(data, callback) {
        this._httpPost(this.createPublishUrl(), data, callback);
        return this;
    },
    getServices: function getServices(data, callback) {
        this._httpGet(this.createServicesUrl(), data, callback);
        return this;
    },
    deletePluginInstance: function deletePluginInstance(id, data, callback) {
        this._httpPost(this.createDeletePluginInstanceUrl(id), data, callback);
        return this;
    }
};
"use strict";
/**
 * Created by Daniel on 3/30/2015.
 * only allow reads without secure api key
 * cache data here so that we dont hit the server for the same info over and over
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function DatastoreAPI(appId, pluginId, instanceId, liveMode, writeKey /*, publishKey*/) {

    if (!window.appContext || !window.appContext.currentApp) {
        console.warn("invalid appContext in datastore");
        //return;
        //If this not an issue after Augest First , 2016 then remove this if statement
    }

    this.enableCache = window.location.protocol.indexOf('http') < 0; // enable for non web only
    this.dataStoreUrl = window.siteConfig.endPoints.datastoreHost;

    this._featureSecurityAccess = undefined;
    if (window.appContext && window.appContext.currentApp && window.appContext.currentApp.config) {
        if (typeof window.appContext.currentApp.config.featureSecurityAccess == 'undefined') {
            if (window.appContext.currentApp.config.type == "enterprise") {
                this._featureSecurityAccess = 'enabled';
            }
        } else {
            this._featureSecurityAccess = window.appContext.currentApp.config.featureSecurityAccess;
        }
    }

    if ((typeof appId === "undefined" ? "undefined" : _typeof(appId)) == "object") {
        var config = appId;
        this.appId = config.appId;
        this.pluginId = config.pluginId;
        this.instanceId = config.instanceId;
        this.liveMode = config.liveMode;
        this.writeKey = config.writeKey || (window.appContext.currentApp ? window.appContext.currentApp.keys.datastoreKey : null);
    } else {
        this.appId = appId;
        this.pluginId = pluginId;
        this.instanceId = instanceId;
        this.liveMode = liveMode;
        if (writeKey) this.writeKey = writeKey;else if (window.appContext.currentApp && window.appContext.currentApp.keys && window.appContext.currentApp.keys.datastoreKey) this.writeKey = window.appContext.currentApp.keys.datastoreKey;else if (window.appContext.currentApp && window.appContext.currentApp.datastoreWriteKey) this.writeKey = window.appContext.currentApp.datastoreWriteKey;else this.writeKey = null;
    }

    if (typeof CustomEvent == "undefined") console.warn("Browser doesn't support CustomEvent");

    // check for backward compatibility with old SDK versions. overrides.js loads in SDK only.
    if (typeof RemoteDatastore == "undefined" && document.querySelector('script[src="scripts/overrides.js"]')) {
        console.error("SDK is outdated. Please update to the most recent version.");
        throw "SDK is outdated. Please update to the most recent version.";
    }

    var remoteDatastoreProvider = new RemoteDatastore(this.appId, this.pluginId, this.instanceId, this.liveMode, this.dataStoreUrl);
    if (this.enableCache && typeof OfflineDatastore != 'undefined') {
        this._provider = new OfflineDatastore(this.appId, this.pluginId, this.instanceId, this.liveMode, remoteDatastoreProvider);
    } else {
        this._provider = remoteDatastoreProvider;
    }
}

DatastoreAPI.prototype = {
    deviceOnline: function deviceOnline() {
        if (typeof navigator != "undefined" && navigator.connection && navigator.connection.type) return navigator.connection.type != "none";else return true;
    },
    onUpdate: function onUpdate(callback) {},
    triggerOnUpdate: function triggerOnUpdate(data) {
        if (this.onUpdate) this.onUpdate(data);
    },
    onRefresh: function onRefresh(callback) {
        document.addEventListener('datastoreOnRefresh', callback, false);
    },
    triggerOnRefresh: function triggerOnRefresh(data) {
        var onUpdateEvent = new CustomEvent('datastoreOnRefresh', { 'detail': data });
        document.dispatchEvent(onUpdateEvent);
    },
    onDisableRefresh: function onDisableRefresh(callback) {
        document.addEventListener('datastoreOnDisableRefresh', callback, false);
    },
    disableRefresh: function disableRefresh() {
        document.dispatchEvent(new CustomEvent('datastoreOnDisableRefresh'));
    },
    resolveTag: function resolveTag(tag) {
        if (tag == null || tag == undefined || tag == "") return 'primary';
        return tag;
    },
    get: function get(obj, callback) {
        if (typeof callback != "function") return; // don't bother

        var self = this;

        var tag;
        var id = '';
        var withDynamicData = false;
        if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) == "object") {
            if (typeof obj.tag == "string") tag = obj.tag;else tag = '';
            if (typeof obj.id == "string") id = obj.id;else id = '';
            withDynamicData = obj.withDynamicData;
        } else if (typeof obj == "string") tag = obj;else if (tag == null || tag == undefined) tag = '';

        if (typeof tag != "string") tag = '';
        var requestTime = Date.now();
        this._provider.get(id, tag, { ds: this,
            obj: obj
        }, withDynamicData, function (err, data) {
            //var responseTime = Date.now() - requestTime;
            //console.log('datastore: response time ' + responseTime);
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                if (data == null) {
                    callback(null, null);
                } else {
                    var saveTag = data.tag;
                    data.tag = tag;
                    if (withDynamicData && data && data.data && data.data._buildfire) {
                        self._dynamicDataSecurityFilter(data.data._buildfire, function (err, result) {
                            data.data._buildfire = result;
                            callback(null, data);
                            data.tag = saveTag;
                        });
                    } else {
                        callback(null, data);
                        data.tag = saveTag;
                    }
                }
            }
        });
        return this;
    },
    save: function save(obj, callback) {
        if (window.toast) window.toast('saving...');
        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var tag = obj.tag,
            data = obj.obj;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
            data = this._cleanUp(data);
            if (typeof angular != "undefined") data = angular.toJson({ data: data, writeKey: this.writeKey, id: obj.id });else data = JSON.stringify({ data: data, writeKey: this.writeKey, id: obj.id });
        }

        var t = this;
        this._provider.save(tag, data, function (err) {
            if (err == 404) {
                if (window.toast) window.toast('404', 'danger');
                callback(null, null);
            } else if (err) {
                if (window.toast) window.toast('error saving', 'danger');
                callback(err);
            } else {
                var result = {
                    id: obj.id,
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    },
    insert: function insert(obj, callback) {

        var tag = obj.tag,
            data = obj.obj,
            checkDuplicate = obj.checkDuplicate;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
            data = this._cleanUp(data);
            data = { data: data, writeKey: this.writeKey };
            if (checkDuplicate) data.checkDuplicate = checkDuplicate;
            data = JSON.stringify(data);
        }

        var t = this;
        this._provider.insert(tag, data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                obj.id = response.id;
                var result = {
                    id: response.id,
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    },
    clone: function clone(obj, callback) {

        var tag = obj.tag,
            data = obj.obj,
            checkDuplicate = obj.checkDuplicate;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
            data = this._cleanUp(data);
            data = { data: data, writeKey: this.writeKey };
            if (checkDuplicate) data.checkDuplicate = checkDuplicate;
            data = JSON.stringify(data);
        }

        var t = this;
        this._provider.clone(tag, data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                obj.id = response.id;
                var result = {
                    id: response.id,
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    },
    bulkInsert: function bulkInsert(obj, callback) {
        var tag = obj.tag,
            data = obj.obj;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
            data = this._cleanUp(data);
            data = JSON.stringify({ data: data, writeKey: this.writeKey, checkDuplicate: false });
        }

        var t = this;
        this._provider.bulkInsert(tag, data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                var result = {
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    },
    update: function update(args, callback) {
        if (window.toast) window.toast('saving...');
        var tag = args.tag,
            data = args.obj;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
            data = this._cleanUp(data);
            data = JSON.stringify({ id: args.id, data: data, writeKey: this.writeKey });
        }

        var t = this;
        this._provider.update(tag, data, function (err, response) {
            if (err == 404) {
                if (window.toast) window.toast('404');
                callback(null, null);
            } else if (err) {
                if (window.toast) window.toast('error updating');
                callback(err);
            } else {
                //if (window.toast)window.toast('saved.');
                response.record.tag = args.tag;
                callback(null, response.record);
                t.triggerOnUpdate(response.record);
            }
        });
        return this;
    },
    searchAndUpdate: function searchAndUpdate(args, callback) {
        if (window.toast) window.toast('saving...');
        var tag = args.tag,
            data = args.obj;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
            data = this._cleanUp(data);
            data = JSON.stringify({ search: args.search, data: data, writeKey: this.writeKey });
        }

        var t = this;
        this._provider.searchAndUpdate(tag, data, function (err, response) {
            if (err == 404) {
                if (window.toast) window.toast('404');
                callback(null, null);
            } else if (err) {
                if (window.toast) window.toast('error updating');
                callback(err);
            } else {
                //if (window.toast)window.toast('saved.');
                callback(null, response);
                t.triggerOnUpdate(response);
            }
        });
        return this;
    },
    delete: function _delete(args, callback) {

        var tag = args.tag;

        var data = JSON.stringify({ writeKey: this.writeKey });

        var t = this;
        this._provider.delete(tag, args.id, data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                callback(null, response);
                t.triggerOnUpdate(args);
            }
        });
        return this;
    },
    deletePluginInstance: function deletePluginInstance(args, callback) {
        var data = JSON.stringify({ writeKey: this.writeKey });

        var t = this;
        this._provider.deletePluginInstance(args.id, data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                callback(null, response);
                t.triggerOnUpdate(args);
            }
        });
        return this;
    },
    search: function search(packet, callback) {
        var self = this;
        var tag = packet.tag;
        var data = packet.obj;
        if (typeof callback != "function") return; // dont bother

        if (typeof tag != "string") tag = '';

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") data = JSON.stringify(data);

        this._provider.search(tag, packet.obj, data, function (err, data) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                /*try {*/

                if (data == null) callback(null, null);else if (typeof data == "string") callback(null, bfUtils.tryParseJSON(data));else {
                    if (self.pluginId === 'pluginInstances') {
                        //
                        if (typeof userTags != "undefined" && userTags.checkPluginAccessSettings && data.result) {
                            self._pluginInstancesSecurityFilter(data.result);
                        }
                        callback(null, data);
                    } else {
                        callback(null, data);
                    }
                }
                /*}
                catch (e) {
                    callback({data : 'cannot parse data: ' + JSON.stringify(packet) , error : JSON.stringify(e)  });
                }*/
            }
        });
        return this;
    },
    publish: function publish(callback) {
        var data = JSON.stringify({ publishKey: this.publishKey });
        var t = this;
        this._provider.publish(data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                /*try {*/
                callback(null, bfUtils.tryParseJSON(response));
                /*}
                catch (e) {
                    callback('cannot parse data: ' + response);
                }*/
                t.triggerOnUpdate(obj);
            }
        });
        return this;
    },
    getServices: function getServices(data, callback) {
        this._provider.getServices(data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                callback(null, response);
            }
        });
        return this;
    },
    _cleanUp: function _cleanUp(data) {
        if (data) {
            var clone = JSON.parse(JSON.stringify(data));
            this._cleanUpTree(clone);
            return clone;
        } else {
            return data;
        }
    },
    _cleanUpTree: function _cleanUpTree(node) {
        for (var property in node) {
            var subNode = node[property];
            if (property == '_buildfire' && subNode) {
                // clean auto injected _buildfire
                delete subNode.result;
                delete subNode.err;
            } else {
                if (subNode !== null && (typeof subNode === "undefined" ? "undefined" : _typeof(subNode)) == "object") {
                    this._cleanUpTree(node[property]);
                }
            }
        }
    },
    _dynamicDataSecurityFilter: function _dynamicDataSecurityFilter(_buildfire, callback) {
        if (typeof userTags != "undefined" && userTags.checkPluginAccessSettings) {
            for (var key in _buildfire) {
                if (!key) continue;
                var currentInstance = _buildfire[key];
                if (currentInstance && currentInstance.result) {
                    this._pluginInstancesSecurityFilter(currentInstance.result);
                }
            }
        }
        callback(null, _buildfire);
    },
    _pluginInstancesSecurityFilter: function _pluginInstancesSecurityFilter(pluginInstances) {
        var self = this;
        if (pluginInstances) {
            pluginInstances.forEach(function (pInstance) {
                if (pInstance && pInstance.data) {
                    pInstance.hasAccess = true;
                    if (self._featureSecurityAccess === 'enabled') {
                        userTags.checkPluginAccessSettings(pInstance.data, function (err, hasAccess) {
                            pInstance.hasAccess = hasAccess;
                        });
                    }
                }
            });
        }
    }
};
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function UserDatastoreAPI(appId, pluginId, instanceId, isAppUser, writeKey) {

    if (!window.appContext || !window.appContext.currentApp) {
        console.error("invalid appCOntext in userstore");
        return;
    }

    this.enableCache = false; // don't enable, cache is not invalidated properly
    this.dataStoreUrl = window.siteConfig.endPoints.datastoreHost;

    if ((typeof appId === "undefined" ? "undefined" : _typeof(appId)) == "object") {
        var config = appId;
        this.appId = config.appId;
        this.pluginId = config.pluginId;
        this.instanceId = config.instanceId;
        this.isAppUser = config.type != 'control';
        if (!this.isAppUser) this.writeKey = config.writeKey || (window.appContext.currentApp ? window.appContext.currentApp.keys.datastoreKey : null);else this.writeKey = authAPI.getCurrentUser() ? authAPI.getCurrentUser()._id : null;
    } else {
        this.appId = appId;
        this.pluginId = pluginId;
        this.instanceId = instanceId;

        this.isAppUser = isAppUser;
        if (!this.isAppUser) this.writeKey = writeKey || (window.appContext.currentApp ? window.appContext.currentApp.keys.datastoreKey : null);else this.writeKey = authAPI.getCurrentUser() ? authAPI.getCurrentUser()._id : null;
    }

    if (typeof CustomEvent == "undefined") console.warn("Browser doesnt support CustomEvent");
}

UserDatastoreAPI.prototype = {
    onUpdate: function onUpdate(callback) {

        //document.addEventListener('datastoreOnUpdate', callback, false);
    },
    triggerOnUpdate: function triggerOnUpdate(data) {
        if (this.onUpdate) this.onUpdate(data);
        //var onUpdateEvent = new CustomEvent('datastoreOnUpdate', {'detail': data});
        //document.dispatchEvent(onUpdateEvent);
    },
    onRefresh: function onRefresh(callback) {
        document.addEventListener('userDataOnRefresh', callback, false);
    },
    triggerOnRefresh: function triggerOnRefresh(data) {
        var onUpdateEvent = new CustomEvent('userDataOnRefresh', { 'detail': data });
        document.dispatchEvent(onUpdateEvent);
    },
    onDisableRefresh: function onDisableRefresh(callback) {
        document.addEventListener('userDatastoreOnDisableRefresh', callback, false);
    },
    disableRefresh: function disableRefresh() {
        document.dispatchEvent(new CustomEvent('userDatastoreOnDisableRefresh'));
    },
    resolveTag: function resolveTag(tag) {
        if (tag == null || tag == undefined || tag == "") return 'primary';
        return tag;
    },
    createReadUrl: function createReadUrl(tag, userToken, id) {
        return this.dataStoreUrl + "/user/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + userToken + "/" + id;
    },
    createSearchUrl: function createSearchUrl(tag) {
        return this.dataStoreUrl + "/user/search/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/";
    },
    createWriteUrl: function createWriteUrl(tag, userToken) {
        return this.dataStoreUrl + "/user/insert/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + userToken + "/";
    },
    createSearchAndUpdateUrl: function createSearchAndUpdateUrl(tag, userToken) {
        return this.dataStoreUrl + "/user/searchAndUpdate/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + userToken + "/";
    },
    createDeleteUrl: function createDeleteUrl(tag, id, userToken) {
        return this.dataStoreUrl + "/user/delete/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + userToken + "/" + id;
    },
    createSaveUrl: function createSaveUrl(tag, userToken) {
        return this.dataStoreUrl + "/user/save/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + userToken + "/";
    },
    createBulkInsertUrl: function createBulkInsertUrl(tag, userToken) {
        return this.dataStoreUrl + "/user/bulkInsert/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + userToken + "/";
    },

    _httpGet: function _httpGet(url, context, callback) {
        if (typeof context == 'function' && !callback) {
            callback = context;
            context = this;
        }
        bfUtils.http.get(url).success(function (data) {
            callback.apply(context, [null, data]);
        }).error(function (err, status) {
            err = err || "http error with status: " + status;
            callback.apply(context, [err]);
            console.error('user datastore GET Error: ', url, err);
        });
    },
    _httpPost: function _httpPost(url, data, callback) {

        bfUtils.http.post(url, data).success(function (result) {
            callback(null, result);
        }).error(function (err, status) {
            err = err || "http error with status: " + status;
            callback(err);
            console.error('user datastore POST Result: ', url, err);
        });
    },
    _httpPut: function _httpPut(url, data, callback) {
        bfUtils.http.put(url, data).success(function (result) {
            callback(null, result);
        }).error(function (err, status) {
            err = err || "http error with status: " + status;
            callback(err);
            console.error('user datastore PUT Result: ', url, err);
        });
    },
    get: function get(obj, callback) {
        console.log('user datastore: get ' + JSON.stringify(obj));
        if (typeof callback != "function") return; // don't bother

        /*
         ///create a delay
         console.warn('create artificial delay >>');
         var originalCallback=callback;;
         callback = function(err,data){ setTimeout(function(){
         console.warn('<< resume');
         originalCallback(err,data)
         },5000); };
         */
        if (this.isAppUser) this.writeKey = authAPI.getCurrentUser() ? authAPI.getCurrentUser()._id : null;

        if (!this.writeKey) {
            console.error("no write key has been provided");
            callback('no logged in user found', null);
            return;
        }
        var tag;
        var id = '';
        var withDynamicData = false;
        if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) == "object") {
            if (typeof obj.tag == "string") tag = obj.tag;else tag = '';
            if (typeof obj.id == "string") id = obj.id;else id = '';
        } else if (typeof obj == "string") tag = obj;else if (tag == null || tag == undefined) tag = '';

        if (typeof tag != "string") tag = '';

        //check if the dataDump record exist
        //if true : return cached record in callback ,continue with http call (without callback) ,update local cache , trigger on update
        //else : continue with http normally

        var isCallBackDone = false;
        var cachedData = null;
        //check local storage
        try {
            if (this.enableCache && typeof userDataDumpAPI !== 'undefined') {
                console.log('data cache: check for cache');
                cachedData = userDataDumpAPI.getData(this.appId, this.pluginId, this.instanceId, this.resolveTag(tag), obj.id);
                if (cachedData) {
                    console.log('data cache: found cache');
                    var result = cachedData;
                    result.tag = obj.tag;
                    result.obj = obj.obj;
                    callback(null, result);
                    isCallBackDone = true;
                }
            }
        } catch (ex) {
            debugger;
            console.error('dataDump error: ' + ex);
        }

        //var t = this;
        var requestTime = Date.now();
        this._httpGet(this.createReadUrl(tag, this.writeKey, id, withDynamicData), { ds: this,
            isCallBackDone: isCallBackDone,
            obj: obj,
            userDataDumpAPI: window.userDataDumpAPI
        }, function (err, data) {
            var context = this;
            var responseTime = Date.now() - requestTime;
            console.log('user datastore: response time ' + responseTime);
            if (err) {
                if (!context.isCallBackDone) callback(err);
            } else if (err == 404) {
                if (!context.isCallBackDone) callback(null, null);
            } else {
                try {
                    if (data == null) {
                        if (!context.isCallBackDone) callback(null, null);
                    } else {
                        if (context.ds.enableCache && typeof context.userDataDumpAPI !== 'undefined') context.userDataDumpAPI.setData(context.ds.appId, context.ds.pluginId, context.ds.instanceId, context.ds.resolveTag(context.obj.tag), context.obj.id, data);

                        data.tag = context.obj.tag;
                        if (!context.isCallBackDone) callback(null, data);else if (cachedData && cachedData.lastUpdated != data.lastUpdated) {
                            console.log('data cache: send updated object onUpdate');
                            // needs some time to load before sending the update
                            //setTimeout(function(){context.ds.triggerOnUpdate(data);},3000);
                            context.ds.triggerOnUpdate(data);
                        }
                    }
                } catch (e) {
                    if (!isCallBackDone) callback(e);
                }
            }
        });
        return this;
    },
    save: function save(obj, callback) {
        if (window.toast) window.toast('saving...');
        if (this.isAppUser) {
            this.writeKey = authAPI.getCurrentUser() ? authAPI.getCurrentUser()._id : null;
        }

        if (!this.writeKey) {
            console.error("no write key has been provided");
            if (callback) callback('no logged in user found', null);
            return;
        }
        var tag = obj.tag,
            data = obj.obj,
            userToken = obj.userToken ? obj.userToken : this.writeKey;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
            if (typeof angular != "undefined") {
                if (this.isAppUser) data = angular.toJson({ data: data, userToken: this.writeKey, id: obj.id });else data = angular.toJson({ data: data, writeKey: this.writeKey, id: obj.id });
            } else {
                if (this.isAppUser) data = JSON.stringify({ data: data, userToken: this.writeKey, id: obj.id });else data = JSON.stringify({ data: data, writeKey: this.writeKey, id: obj.id });
            }
        }

        var t = this;
        this._httpPost(this.createSaveUrl(tag, userToken), data, function (err, response) {
            if (err == 404) {
                if (window.toast) window.toast('404', 'danger');
                callback(null, null);
            } else if (err) {
                if (window.toast) window.toast('error saving', 'danger');
                callback(err);
            } else {
                //if (window.toast)window.toast('saved');
                var result = {
                    id: obj.id,
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    },
    insert: function insert(obj, callback) {

        if (this.isAppUser) {
            this.writeKey = authAPI.getCurrentUser() ? authAPI.getCurrentUser()._id : null;
        }

        if (!this.writeKey) {
            console.error("no write key has been provided");
            if (callback) callback('no logged in user found', null);
            return;
        }
        var tag = obj.tag,
            data = obj.obj,
            checkDuplicate = obj.checkDuplicate,
            userToken = obj.userToken ? obj.userToken : this.writeKey;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {

            if (this.isAppUser) data = { data: data, userToken: this.writeKey };else data = { data: data, writeKey: this.writeKey };

            if (checkDuplicate) data.checkDuplicate = checkDuplicate;
            data = JSON.stringify(data);
        }

        var t = this;
        this._httpPost(this.createWriteUrl(tag, userToken), data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                obj.id = response.id;
                var result = {
                    id: response.id,
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    },
    bulkInsert: function bulkInsert(obj, callback) {

        if (this.isAppUser) {
            this.writeKey = authAPI.getCurrentUser() ? authAPI.getCurrentUser()._id : null;
        }

        if (!this.writeKey) {
            console.error("no write key has been provided");
            if (callback) callback('no logged in user found', null);
            return;
        }

        var tag = obj.tag,
            data = obj.obj,
            userToken = obj.userToken ? obj.userToken : this.writeKey;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {

            if (this.isAppUser) data = JSON.stringify({ data: data, userToken: this.writeKey, checkDuplicate: false });else data = JSON.stringify({ data: data, writeKey: this.writeKey, checkDuplicate: false });
        }

        var t = this;
        this._httpPost(this.createBulkInsertUrl(tag, userToken), data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                var result = {
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    },
    update: function update(args, callback) {
        if (window.toast) window.toast('saving...');
        if (this.isAppUser) {
            this.writeKey = authAPI.getCurrentUser() ? authAPI.getCurrentUser()._id : null;
        }

        if (!this.writeKey) {
            console.error("no write key has been provided");
            if (callback) callback('no logged in user found', null);
            return;
        }
        var tag = args.tag,
            data = args.obj,
            userToken = args.userToken;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {

            if (this.isAppUser) data = JSON.stringify({ id: args.id, data: data, userToken: this.writeKey });else data = JSON.stringify({ id: args.id, data: data, writeKey: this.writeKey });
        }

        var t = this;
        this._httpPut(this.createWriteUrl(tag, userToken), data, function (err, response) {
            if (err == 404) {
                if (window.toast) window.toast('404');
                callback(null, null);
            } else if (err) {
                if (window.toast) window.toast('error updating');
                callback(err);
            } else {
                //if (window.toast)window.toast('saved.');
                response.record.tag = args.tag;
                callback(null, response.record);
                t.triggerOnUpdate(response.record);
            }
        });
        return this;
    },
    searchAndUpdate: function searchAndUpdate(args, callback) {
        if (window.toast) window.toast('saving...');
        if (this.isAppUser) {
            this.writeKey = authAPI.getCurrentUser() ? authAPI.getCurrentUser()._id : null;
        }

        if (!this.writeKey) {
            console.error("no write key has been provided");
            if (callback) callback('no logged in user found', null);
            return;
        }
        var tag = args.tag,
            data = args.obj,
            userToken = args.userToken;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
            if (this.isAppUser) data = JSON.stringify({ search: args.search, data: data, userToken: this.writeKey });else data = JSON.stringify({ search: args.search, data: data, writeKey: this.writeKey });
        }

        var t = this;
        this._httpPost(this.createSearchAndUpdateUrl(tag, userToken), data, function (err, response) {
            if (err == 404) {
                if (window.toast) window.toast('404');
                callback(null, null);
            } else if (err) {
                if (window.toast) window.toast('error updating');
                callback(err);
            } else {
                //if (window.toast)window.toast('saved.');
                callback(null, response);
                t.triggerOnUpdate(response);
            }
        });
        return this;
    },
    delete: function _delete(args, callback) {
        if (this.isAppUser) {
            this.writeKey = authAPI.getCurrentUser() ? authAPI.getCurrentUser()._id : null;
        }

        if (!this.writeKey) {
            console.error("no write key has been provided");
            if (callback) callback('no logged in user found', null);
            return;
        }
        var tag = args.tag,
            userToken = args.userToken;
        var data = {};
        if (this.isAppUser) data = JSON.stringify({ userToken: this.writeKey });else data = JSON.stringify({ writeKey: this.writeKey });

        var t = this;
        this._httpPost(this.createDeleteUrl(tag, args.id, userToken), data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                callback(null, response);
                t.triggerOnUpdate(args);
            }
        });
        return this;
    },
    search: function search(packet, callback) {

        if (this.isAppUser) this.writeKey = authAPI.getCurrentUser() ? authAPI.getCurrentUser()._id : null;

        if (!this.writeKey) {
            console.error("no write key has been provided");
            if (callback) callback('no logged in user found', null);
            return;
        }
        var tag = packet.tag;
        var data = packet.obj;
        if (typeof callback != "function") return; // dont bother

        //if(typeof(data) != "object")debugger;

        if (typeof tag != "string") tag = '';

        if (typeof data == "string") data = JSON.parse(data);

        if (this.isAppUser) data.userToken = this.writeKey;else data.writeKey = this.writeKey;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") data = JSON.stringify(data);

        this._httpPost(this.createSearchUrl(tag), data, function (err, data) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                /*try {*/

                if (data == null) callback(null, null);else if (typeof data == "string") callback(null, bfUtils.tryParseJSON(data));else callback(null, data);
                /*}
                catch (e) {
                    callback('cannot parse data: ' + data);
                }*/
            }
        });
        return this;
    },

    dataDump: function dataDump(callback) {
        if (this.isAppUser) this.writeKey = authAPI.getCurrentUser() ? authAPI.getCurrentUser()._id : null;

        if (!this.writeKey) {
            console.error("no write key has been provided");
            if (callback) callback('no logged in user found', null);
            return;
        }
        var t = this;
        this._httpget(this.createDataDumpUrl(), function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                /*try {*/
                callback(null, bfUtils.tryParseJSON(response));
                /*}
                catch (e) {
                    callback('cannot parse data: ' + response);
                }*/
                t.triggerOnUpdate(obj);
            }
        });
        return this;
    }

};
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function PublicDatastoreAPI(appId, pluginId, instanceId) {

    if (!window.appContext || !window.appContext.currentApp) {
        console.error("invalid appCOntext in publicdata");
        return;
    }

    this.enableCache = true; // window.location.protocol.indexOf('http') < 0; // enable for non web only
    this.dataStoreUrl = window.siteConfig.endPoints.datastoreHost;

    if ((typeof appId === "undefined" ? "undefined" : _typeof(appId)) == "object") {
        var config = appId;
        this.appId = config.appId;
        this.pluginId = config.pluginId;
        this.instanceId = config.instanceId;

        this.writeKey = "public";
    } else {
        this.appId = appId;
        this.pluginId = pluginId;
        this.instanceId = instanceId;

        this.writeKey = "public";
    }

    if (typeof CustomEvent == "undefined") console.warn("Browser doesnt support CustomEvent");
}

PublicDatastoreAPI.prototype = {
    onUpdate: function onUpdate(callback) {
        document.addEventListener('publicDataOnUpdate', callback, false);
    },
    triggerOnUpdate: function triggerOnUpdate(data) {
        if (this.onUpdate) this.onUpdate(data);
        var onUpdateEvent = new CustomEvent('publicDataOnUpdate', { 'detail': data });
        document.dispatchEvent(onUpdateEvent);
    },
    onRefresh: function onRefresh(callback) {
        document.addEventListener('publicDataOnRefresh', callback, false);
    },
    triggerOnRefresh: function triggerOnRefresh(data) {
        var onUpdateEvent = new CustomEvent('publicDataOnRefresh', { 'detail': data });
        document.dispatchEvent(onUpdateEvent);
    },
    onDisableRefresh: function onDisableRefresh(callback) {
        document.addEventListener('publicDatastoreOnDisableRefresh', callback, false);
    },
    disableRefresh: function disableRefresh() {
        document.dispatchEvent(new CustomEvent('publicDatastoreOnDisableRefresh'));
    },
    resolveTag: function resolveTag(tag) {
        if (tag == null || tag == undefined || tag == "") return 'primary';
        return tag;
    },
    createReadUrl: function createReadUrl(tag, id) {
        return this.dataStoreUrl + "/user/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + "public" + "/" + id;
    },
    createSearchUrl: function createSearchUrl(tag) {
        return this.dataStoreUrl + "/user/search/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/";
    },
    createWriteUrl: function createWriteUrl(tag) {
        return this.dataStoreUrl + "/user/insert/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + "public" + "/";
    },
    createSearchAndUpdateUrl: function createSearchAndUpdateUrl(tag) {
        return this.dataStoreUrl + "/user/searchAndUpdate/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + "public" + "/";
    },
    createDeleteUrl: function createDeleteUrl(tag, id) {
        return this.dataStoreUrl + "/user/delete/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + "public" + "/" + id;
    },
    createSaveUrl: function createSaveUrl(tag) {
        return this.dataStoreUrl + "/user/save/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + "public" + "/";
    },
    createBulkInsertUrl: function createBulkInsertUrl(tag) {
        return this.dataStoreUrl + "/user/bulkInsert/" + this.appId + "/" + this.pluginId + "/" + this.instanceId + "/" + this.resolveTag(tag) + "/" + "public" + "/";
    },

    _httpGet: function _httpGet(url, context, callback) {
        if (typeof context == 'function' && !callback) {
            callback = context;
            context = this;
        }
        bfUtils.http.get(url).success(function (data) {
            callback.apply(context, [null, data]);
        }).error(function (err) {
            callback.apply(context, [err]);
            console.error('public datastore GET Error: ', url, err);
        });
    },
    _httpPost: function _httpPost(url, data, callback) {

        bfUtils.http.post(url, data).success(function (result) {
            callback(null, result);
        }).error(function (err) {
            callback(err);
            console.error('public datastore POST Result: ', url, err);
        });
    },
    _httpPut: function _httpPut(url, data, callback) {
        bfUtils.http.put(url, data).success(function (result) {
            callback(null, result);
        }).error(function (err) {
            callback(err);
            console.error('public datastore PUT Result: ', url, err);
        });
    },
    get: function get(obj, callback) {
        console.log('public datastore: get ' + JSON.stringify(obj));
        if (typeof callback != "function") return; // don't bother

        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var tag;
        var id = '';
        var withDynamicData = false;
        if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) == "object") {
            if (typeof obj.tag == "string") tag = obj.tag;else tag = '';
            if (typeof obj.id == "string") id = obj.id;else id = '';
        } else if (typeof obj == "string") tag = obj;else if (tag == null || tag == undefined) tag = '';

        if (typeof tag != "string") tag = '';

        //check if the dataDump record exist
        //if true : return cached record in callback ,continue with http call (without callback) ,update local cache , trigger on update
        //else : continue with http normally

        var isCallBackDone = false;
        var cachedData = null;
        //check local storage
        try {
            if (this.enableCache && typeof userDataDumpAPI !== 'undefined') {
                console.log('data cache: check for cache');
                cachedData = userDataDumpAPI.getData(this.appId, this.pluginId, this.instanceId, this.resolveTag(tag), obj.id);
                if (cachedData) {
                    console.log('data cache: found cache');
                    var result = cachedData;
                    result.tag = obj.tag;
                    result.obj = obj.obj;
                    callback(null, result);
                    isCallBackDone = true;
                }
            }
        } catch (ex) {
            debugger;
            console.error('dataDump error: ' + ex);
        }

        //var t = this;
        var requestTime = Date.now();
        this._httpGet(this.createReadUrl(tag, id, withDynamicData), {
            ds: this,
            isCallBackDone: isCallBackDone,
            obj: obj,
            userDataDumpAPI: window.userDataDumpAPI
        }, function (err, data) {
            var context = this;
            var responseTime = Date.now() - requestTime;
            console.log('public datastore: response time ' + responseTime);
            if (err) {
                if (!context.isCallBackDone) callback(err);
            } else if (err == 404) {
                if (!context.isCallBackDone) callback(null, null);
            } else {
                try {
                    if (data == null) {
                        if (!context.isCallBackDone) callback(null, null);
                    } else {
                        if (context.ds.enableCache && typeof context.userDataDumpAPI !== 'undefined') context.userDataDumpAPI.setData(context.ds.appId, context.ds.pluginId, context.ds.instanceId, context.ds.resolveTag(context.obj.tag), context.obj.id, data);

                        data.tag = context.obj.tag;
                        if (!context.isCallBackDone) callback(null, data);else if (cachedData && cachedData.lastUpdated != data.lastUpdated) {
                            console.log('data cache: send updated object onUpdate');
                            // needs some time to load before sending the update
                            //setTimeout(function(){context.ds.triggerOnUpdate(data);},3000);
                            context.ds.triggerOnUpdate(data);
                        }
                    }
                } catch (e) {
                    if (!isCallBackDone) callback(e);
                }
            }
        });
        return this;
    },
    save: function save(obj, callback) {
        if (window.toast) window.toast('saving...');

        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var tag = obj.tag,
            data = obj.obj;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
            if (typeof angular != "undefined") {
                data = angular.toJson({ data: data, userToken: this.writeKey, id: obj.id });
            } else {
                data = JSON.stringify({ data: data, userToken: this.writeKey, id: obj.id });
            }
        }

        var t = this;
        this._httpPost(this.createSaveUrl(tag), data, function (err, response) {
            if (err == 404) {
                if (window.toast) window.toast('404', 'danger');
                callback(null, null);
            } else if (err) {
                if (window.toast) window.toast('error saving', 'danger');
                callback(err);
            } else {
                //if (window.toast)window.toast('saved');
                var result = {
                    id: obj.id,
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    },
    insert: function insert(obj, callback) {

        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var tag = obj.tag,
            data = obj.obj,
            checkDuplicate = obj.checkDuplicate;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {

            data = { data: data, userToken: this.writeKey };

            if (checkDuplicate) data.checkDuplicate = checkDuplicate;
            data = JSON.stringify(data);
        }

        var t = this;
        this._httpPost(this.createWriteUrl(tag), data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                obj.id = response.id;
                var result = {
                    id: response.id,
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    },
    bulkInsert: function bulkInsert(obj, callback) {

        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }

        var tag = obj.tag,
            data = obj.obj;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
            data = JSON.stringify({ data: data, userToken: this.writeKey, checkDuplicate: false });
        }

        var t = this;
        this._httpPost(this.createBulkInsertUrl(tag), data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                var result = {
                    data: obj.obj,
                    tag: tag
                };
                callback(null, result);
                t.triggerOnUpdate(result);
            }
        });
        return this;
    },
    update: function update(args, callback) {
        if (window.toast) window.toast('saving...');

        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var tag = args.tag,
            data = args.obj;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
            data = JSON.stringify({ id: args.id, data: data, userToken: this.writeKey });
        }

        var t = this;
        this._httpPut(this.createWriteUrl(tag), data, function (err, response) {
            if (err == 404) {
                if (window.toast) window.toast('404');
                callback(null, null);
            } else if (err) {
                if (window.toast) window.toast('error updating');
                callback(err);
            } else {
                //if (window.toast)window.toast('saved.');
                response.record.tag = args.tag;
                callback(null, response.record);
                t.triggerOnUpdate(response.record);
            }
        });
        return this;
    },
    searchAndUpdate: function searchAndUpdate(args, callback) {
        if (window.toast) window.toast('saving...');

        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var tag = args.tag,
            data = args.obj;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
            data = JSON.stringify({ search: args.search, data: data, userToken: this.writeKey });
        }

        var t = this;
        this._httpPost(this.createSearchAndUpdateUrl(tag), data, function (err, response) {
            if (err == 404) {
                if (window.toast) window.toast('404');
                callback(null, null);
            } else if (err) {
                if (window.toast) window.toast('error updating');
                callback(err);
            } else {
                //if (window.toast)window.toast('saved.');
                callback(null, response);
                t.triggerOnUpdate(response);
            }
        });
        return this;
    },
    delete: function _delete(args, callback) {
        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var tag = args.tag;
        var data = JSON.stringify({ userToken: this.writeKey });

        var t = this;
        this._httpPost(this.createDeleteUrl(tag, args.id), data, function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                callback(null, response);
                t.triggerOnUpdate(args);
            }
        });
        return this;
    },
    search: function search(packet, callback) {

        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var tag = packet.tag;
        var data = packet.obj;
        if (typeof callback != "function") return; // dont bother

        //if(typeof(data) != "object")debugger;

        if (typeof tag != "string") tag = '';

        if (typeof data == "string") data = JSON.parse(data);

        data.userToken = this.writeKey;

        if ((typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") data = JSON.stringify(data);

        this._httpPost(this.createSearchUrl(tag), data, function (err, data) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                /*try {*/

                if (data == null) callback(null, null);else if (typeof data == "string") callback(null, bfUtils.tryParseJSON(data));else callback(null, data);
                /*}
                 catch (e) {
                 callback('cannot parse data: ' + data);
                 }*/
            }
        });
        return this;
    },

    dataDump: function dataDump(callback) {
        if (!this.writeKey) {
            console.error("no write key has been provided");
            return;
        }
        var t = this;
        this._httpget(this.createDataDumpUrl(), function (err, response) {
            if (err == 404) callback(null, null);else if (err) callback(err);else {
                /*try {*/
                callback(null, bfUtils.tryParseJSON(response));
                /*}
                 catch (e) {
                 callback('cannot parse data: ' + response);
                 }*/
                t.triggerOnUpdate(obj);
            }
        });
        return this;
    }
};
"use strict";
/**
 * Created by Daniel on 3/30/2015.
 * only allow reads without secure api key
 * cache data here so that we dont hit the server for the same info over and over
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function AnalyticsAPI(appId, pluginId, instanceId, liveMode, developerId) {
    this.analyticsHostUrl = siteConfig.endPoints.analyticsHost;
    if ((typeof appId === "undefined" ? "undefined" : _typeof(appId)) == "object") {
        var config = appId;
        this.appId = config.appId;
        this.pluginId = config.pluginId;
        this.instanceId = config.instanceId;
        this.liveMode = config.liveMode;
        this.developerId = config.developerId;
    } else {
        this.appId = appId;
        this.pluginId = pluginId;
        this.instanceId = instanceId;
        this.liveMode = liveMode;
        this.developerId = developerId;
    }
    this.source = typeof device != "undefined" && device.platform ? "app" : "web";

    if (window.whitelabelContext && window.whitelabelContext.whitelabelId) {
        this.whitelabelId = window.whitelabelContext.whitelabelId;
    }

    this._user = this._getUser();

    //trackInstall in app and in pwa
    if (window.appContext && window.appContext.liveMode) {
        this._trackInstall();
    }
}

AnalyticsAPI.prototype = {
    _getIpInfo: function _getIpInfo(callback) {
        var _this = this;

        function _daysDiff(date1, date2) {
            //Get 1 day in milliseconds
            var one_day = 1000 * 60 * 60 * 24;

            // Convert both dates to milliseconds
            var date1_ms = date1.getTime();
            var date2_ms = date2.getTime();

            // Calculate the difference in milliseconds
            var difference_ms = Math.abs(date2_ms - date1_ms);

            // Convert back to days and return
            return Math.round(difference_ms / one_day);
        }

        function getNewIPInfo() {
            var request = new XMLHttpRequest();
            request.open('GET', 'https://ipapi.co/json/', true);
            request.onreadystatechange = function () {
                if (request.readyState == 4) {
                    if (request.status >= 200 && request.status < 400) {
                        var formattedData = null;
                        if (request.responseText) {
                            var data = {};
                            try {
                                data = JSON.parse(request.responseText);
                            } catch (e) {
                                data = {};
                            }
                            formattedData = {
                                city: data.city,
                                country: data.country_name,
                                countryCode: data.country,
                                lat: data.latitude,
                                lon: data.longitude,
                                regionName: data.region,
                                timezone: data.timezone,
                                zip: data.postal,
                                ip: data.ip
                            };
                        }
                        saveGeoLocation(formattedData, true);
                    }
                    AnalyticsAPI.IPInfoCalled = false;
                }
            };
            request.send(null);
        }

        function saveGeoLocation(data, isNewData) {
            if (isNewData) {
                var _localData = {
                    data: data,
                    lastSyncDate: new Date()
                };
                localStorage.setItem("analyticsUserIpInfo", JSON.stringify(_localData));
            }
        }

        var analyticsUserIpInfo = localStorage.getItem('analyticsUserIpInfo');
        if (analyticsUserIpInfo) {
            try {
                analyticsUserIpInfo = JSON.parse(analyticsUserIpInfo);
            } catch (err) {
                analyticsUserIpInfo = null;
            }

            var _today = new Date();
            var _lastSyncDate = analyticsUserIpInfo && analyticsUserIpInfo.lastSyncDate ? new Date(analyticsUserIpInfo.lastSyncDate) : new Date();
            if (_daysDiff(_lastSyncDate, _today) <= 30 && analyticsUserIpInfo && analyticsUserIpInfo.data) {
                if (callback) {
                    callback(analyticsUserIpInfo.data);
                }
            } else {
                if (callback) {
                    callback(analyticsUserIpInfo ? analyticsUserIpInfo.data : null);
                }
                if (!AnalyticsAPI.IPInfoCalled) {
                    AnalyticsAPI.IPInfoCalled = true;
                    getNewIPInfo();
                }
            }
        } else {
            if (callback) {
                callback();
            }
            if (!AnalyticsAPI.IPInfoCalled) {
                AnalyticsAPI.IPInfoCalled = true;
                getNewIPInfo();
            }
        }
    },
    _updateMetadata: function _updateMetadata(metadata) {
        var _loggedUser = null;
        var _userObject = localStorage.user || localStorage.AUTH_CURRENT_USER;
        if (_userObject) {
            try {
                _userObject = JSON.parse(_userObject);
                if (localStorage.user) {
                    _loggedUser = {
                        userId: _userObject.userToken,
                        username: _userObject.username,
                        email: _userObject.email || _userObject.username,
                        displayName: _userObject.displayName,
                        firstName: _userObject.firstName,
                        lastName: _userObject.lastName
                    };
                } else {
                    _loggedUser = {
                        userId: _userObject._id,
                        username: _userObject.username,
                        email: _userObject.email || _userObject.username,
                        displayName: _userObject.displayName,
                        firstName: _userObject.firstName,
                        lastName: _userObject.lastName
                    };
                }
            } catch (e) {
                console.warn("could not load analytics user");
                _loggedUser = null;
            }
        }
        metadata.user = _loggedUser;
        if (typeof push != "undefined" && push.deviceId != null) {
            metadata.deviceId = push.deviceId;
        }
    },
    _getUser: function _getUser() {
        if (localStorage.user) {
            try {
                var loggedInUser = JSON.parse(localStorage.user);
                if (loggedInUser) {
                    return { userId: loggedInUser.username };
                }
            } catch (e) {
                console.warn("could not load analytics user");
                return this._getAnonymousUser();
            }
        } else if (localStorage.AUTH_CURRENT_USER) {
            try {
                var loggedInUser = JSON.parse(localStorage.AUTH_CURRENT_USER);
                if (loggedInUser) {
                    return { userId: loggedInUser.username };
                } else if (typeof push != "undefined" && push.deviceId != null) {
                    return { userId: push.deviceId };
                } else return this._getAnonymousUser();
            } catch (e) {
                console.warn("could not load analytics user");
                if (typeof push != "undefined" && push.deviceId != null) {
                    return { userId: push.deviceId };
                } else {
                    return this._getAnonymousUser();
                }
            }
        } else if (typeof push != "undefined" && push.deviceId != null) {
            return { userId: push.deviceId };
        } else {
            return this._getAnonymousUser();
        }
    },
    _getAnonymousUser: function _getAnonymousUser() {
        var localAnalyticsUser = localStorage.getItem('analyticsUser');
        var user;
        if (localAnalyticsUser) {
            try {
                user = JSON.parse(localAnalyticsUser);
            } catch (err) {
                console.log(err);
            }
        }
        if (!user) {
            var segmentClientId = this._getCookie("ajs_anonymous_id");
            if (segmentClientId) {
                user = { anonymousId: segmentClientId.replace('%22', '').replace('%22', '') }; // remove quotes embedded in id
            } else {
                var c = 1;
                var cuniq = function cuniq() {
                    var d = new Date(),
                        m = d.getMilliseconds() + "",
                        u = ++d + m + (++c === 10000 ? c = 1 : c);

                    return u;
                };
                user = { anonymousId: cuniq() };
                try {
                    localStorage.setItem('analyticsUser', JSON.stringify(user));
                } catch (err) {
                    console.log(err);
                }
            }
        }
        return user;
    },
    _getBrowserInfo: function _getBrowserInfo() {
        var browserInfo = {
            path: document.location.pathname,
            referrer: document.referrer,
            url: document.location.href,
            title: document.title,
            platform: window.device && window.device.platform ? window.device.platform.toLowerCase() : ''
        };
        return browserInfo;
    },
    _getCookie: function _getCookie(cname) {
        var name = cname + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) == ' ') {
                c = c.substring(1);
            }if (c.indexOf(name) == 0) return c.substring(name.length, c.length);
        }
        return "";
    },
    _trackInstall: function _trackInstall() {
        var installTrackedItem = localStorage.getItem('INSTALL_TRACKED');
        if (!installTrackedItem) {
            this.trackAction('app/installed', { appId: this.appId });
            localStorage.setItem('INSTALL_TRACKED', 'true');
        }
    },
    trackAction: function trackAction(actionName, properties, callback) {
        var _this = this;
        if (properties) {
            var originalProperties = this._getBrowserInfo();
            for (var originalPropertyName in originalProperties) {
                properties[originalPropertyName] = originalProperties[originalPropertyName]; // keep original properties
            }
        }
        var properties = properties || this._getBrowserInfo();
        properties.source = this.source;
        this._updateMetadata(properties);
        if (this.analyticsHostUrl && actionName) {
            var forceSync = properties ? properties.forceSync : false;
            if (properties) {
                delete properties.forceSync;
            }
            this._getIpInfo(function (userIpInfo) {
                properties.ipInfo = userIpInfo;
                _this._httpPost(_this.analyticsHostUrl + "/event", {
                    type: 'action',
                    value: actionName,
                    metadata: properties,
                    context: {
                        whitelabelId: _this.whitelabelId,
                        appId: _this.appId,
                        pluginId: _this.pluginId,
                        instanceId: _this.instanceId,
                        liveMode: _this.liveMode,
                        developerId: _this.developerId ? _this.developerId : undefined
                    },
                    user: _this._user
                }, !forceSync, function (err, response) {
                    if (callback) {
                        callback();
                    }
                });
            });
        }
        return this;
    },
    trackView: function trackView(viewName, properties, callback) {
        var _this = this;
        if (properties) {
            var originalProperties = this._getBrowserInfo();
            for (var originalPropertyName in originalProperties) {
                properties[originalPropertyName] = originalProperties[originalPropertyName]; // keep original properties
            }
        }
        var properties = properties || this._getBrowserInfo();
        properties.source = this.source;
        this._updateMetadata(properties);
        if (this.analyticsHostUrl && viewName) {
            var ga = this._getCookie('_ga');
            if (ga) {
                var gaContext;
                // send GA on view events only
                gaContext = {};
                gaContext.clientId = ga.substr(6); // remove GAX.X. part from the universal id
            }

            this._getIpInfo(function (userIpInfo) {
                properties.ipInfo = userIpInfo;
                _this._httpPost(_this.analyticsHostUrl + "/event", {
                    type: 'view',
                    value: viewName,
                    metadata: properties,
                    context: {
                        whitelabelId: _this.whitelabelId,
                        appId: _this.appId,
                        pluginId: _this.pluginId,
                        instanceId: _this.instanceId,
                        liveMode: _this.liveMode,
                        developerId: _this.developerId ? _this.developerId : undefined
                    },
                    segmentContext: {
                        'Google Analytics': gaContext
                    },
                    user: _this._user
                }, true, function (err, response) {
                    if (callback) {
                        callback();
                    }
                });
            });
        }
        return this;
    },
    registerPluginEvent: function registerPluginEvent(event, callback) {
        if (!event) {
            if (callback) callback("invalid params", null);
            return;
        }
        if (!event.data) event.data = {};
        if (!event.options) event.options = {};

        var data = event.data;
        if (!data.key) {
            if (callback) callback("Missing event key", null);
            return;
        }

        if (!data.title) {
            if (callback) callback("Missing event title", null);
            return;
        }

        data._titleLowerCase = data.title.toLowerCase();

        var _noAccesskey = this.instanceId + "_pluginEvents";
        var datastore = new DatastoreAPI(this.appId, this.pluginId, _noAccesskey, this.liveMode);

        datastore.searchAndUpdate({
            tag: "events",
            obj: { $set: data },
            search: {
                key: data.key
            }
        }, function (err, result) {
            if (err == null && result && result.nModified == 0) {
                //no event found, then add
                datastore.insert({
                    tag: "events",
                    obj: data,
                    checkDuplicate: false
                }, function (err, result) {
                    //dispatch new register event
                    var onRegisterPluginEvent = new CustomEvent('pluginAnalyticsRegisterEvent', {
                        detail: {
                            data: event.data,
                            options: event.options
                        }
                    });
                    document.dispatchEvent(onRegisterPluginEvent);
                    //#

                    if (callback) callback(err, result);
                });
            } else {
                if (callback) callback(err, result);
            }
        });
    },
    unregisterPluginEvent: function unregisterPluginEvent(event, callback) {
        if (!event || !event.key) {
            if (callback) callback("Missing event key", null);
            return;
        }

        var _noAccesskey = this.instanceId + "_pluginEvents";
        var datastore = new DatastoreAPI(this.appId, this.pluginId, _noAccesskey, this.liveMode);

        datastore.search({
            tag: "events",
            obj: { filter: { "$json.key": event.key } }
        }, function (err, events) {
            if (!err && events && events.length > 0) {
                for (var i = 0; i < events.length; i++) {
                    datastore.delete({ tag: "events", id: events[i].id }, function (err, data) {
                        if (callback) callback(err, data);
                    });
                }
            } else {
                if (callback) callback(err, events);
            }
        });
    },
    getPluginEvents: function getPluginEvents(options, callback) {
        var _noAccesskey = this.instanceId + "_pluginEvents";
        var datastore = new DatastoreAPI(this.appId, this.pluginId, _noAccesskey, this.liveMode);
        if (!options) {
            options = {};
        }

        options.skip = options.skip || 0;
        options.limit = options.limit || 50;

        datastore.search({
            tag: "events",
            obj: options
        }, function (err, data) {
            if (callback) callback(err, data);
        });
    },
    setUsername: function setUsername(username) {
        this._user.userId = username;
        if (this._user.anonymousId) {
            this._user.updateIdentity = true; // next request to bridge anonymousId with userId
        }
    },
    setUserProperties: function setUserProperties(properties) {
        this._user.properties = properties;
        this._user.updateIdentity = true; // next request to update user properties
    },
    _httpPost: function _httpPost(url, data, isAsync, callback) {
        if (window.__$haultEvents) return;
        var xhr = new XMLHttpRequest();
        xhr.open('POST', url, isAsync);
        xhr.setRequestHeader('Content-type', 'application/JSON');
        var t = this;

        //fix nested userId issue
        function _getLastUserIdObject(user) {
            if (user && _typeof(user.userId) == "object") {
                return _getLastUserIdObject(user.userId);
            } else {
                return user;
            }
        }

        if (data.user && data.user.userId && data.user.userId.userId) {
            data.user = _getLastUserIdObject(data.user);
            //override local storage
            localStorage.setItem('analyticsUser', JSON.stringify(data.user));
        }
        //#
        xhr.onreadystatechange = function () {
            //Call a function when the state changes.
            if (xhr.readyState == 4) {
                if (xhr.status >= 200 && xhr.status < 400) {
                    if (t._user && t._user.userId && t._user.userId.userId) {
                        t._user = _getLastUserIdObject(t._user);
                    }

                    if (t._user.updateIdentity) {
                        delete t._user.updateIdentity;
                        delete t._user.properties;
                        delete t._user.anonymousId;
                    }
                    localStorage.setItem('analyticsUser', JSON.stringify(t._user));
                    callback(null, xhr.responseText);
                } else if (xhr.status == 0) window.__$haultEvents = true; //if analytics server is down then stop trying
                else callback(xhr.status);
            }
        };
        var dataString = null;
        try {
            dataString = JSON.stringify(data);
        } catch (err) {
            console.error('error stringifying analytics data', data.context, data.type + ":" + data.value, data.metadata, data, err);
        }
        if (dataString) {
            try {
                xhr.send(dataString);
            } catch (err) {
                if (err.code) {
                    console.error('error sending analytics', err, data, data.context, data.type + ":" + data.value, data.metadata, dataString, err);
                }
            }
        }
    }
};
"use strict";
/**
 * Created by Daniel on 3/30/2015.
 */

function AppearanceAPI(pluginAPI) {
    this.pluginAPI = pluginAPI;
}

AppearanceAPI.prototype = {
    getCSSFiles: function getCSSFiles(data, callback) {
        callback(null, ['https://bootswatch.com/cerulean/bootstrap.css']);
        return this;
    },
    autosizeContainer: function autosizeContainer(data, callback) {
        //debugger;
        this.autosizeContainerHandler(data.height);
        callback(null, null);
    },
    autosizeContainerHandler: function autosizeContainerHandler() {},
    setHeaderVisibility: function setHeaderVisibility(value) {
        var e = document.getElementById('pluginControlHeader');
        var tabs = document.getElementById('pluginControlHeaderTabs');
        if (e) {
            if (value) e.classList.remove('hidden');else e.classList.add('hidden');
        }
        if (tabs) {
            if (value) tabs.classList.remove('hidden');else tabs.classList.add('hidden');
        }
    },
    beforeUpdate: function beforeUpdate(callback) {
        document.addEventListener('appearanceBeforeUpdate', callback, false);
    },
    triggerBeforeUpdate: function triggerBeforeUpdate(data) {
        var beforeUpdateEvent = new CustomEvent('appearanceBeforeUpdate');
        document.dispatchEvent(beforeUpdateEvent);
    },
    onUpdate: function onUpdate(callback) {
        document.addEventListener('appearanceOnUpdate', callback, false);
    },
    triggerOnUpdate: function triggerOnUpdate(data) {
        var onUpdateEvent = new CustomEvent('appearanceOnUpdate');
        document.dispatchEvent(onUpdateEvent);
    }, titlebar: {
        show: function show() {
            AppearanceAPI.prototype.titlebar.toggleVisibility(true);
        },
        hide: function hide() {
            AppearanceAPI.prototype.titlebar.toggleVisibility(false);
        },
        toggleVisibility: function toggleVisibility(visible) {
            var pluginIFrame = document.getElementsByClassName('pluginFrame');
            var scope = undefined;
            if (pluginIFrame.length) scope = angular.element(pluginIFrame[0]).scope();else scope = angular.element(document.getElementById('launcherPlugin')).scope();
            scope.disableAutomaticNavigationBar = true; // navigationBar should not show or hide unless explicitly set
            scope.showNavigationBar = visible;
            if (!scope.$$phase) {
                scope.$apply();
            }
        }
    },
    ready: function ready() {
        window.spinner.hide(true);
    }

};
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Created by Daniel on 8/25/2015.
 */

function Track(title, url, image, album, artist) {
    this.title = title;
    this.url = url;
    this.image = image;
    this.album = album;
    this.artist = artist;
    this.startAt = 0;
    this.lastPosition = 0;
}

var audioPlayer = {
    _audio: null,
    _allowPlay: true,
    _interval: {
        time: 5000,
        id: null
    },
    get audio() {
        if (this._audio == null) {
            if (typeof Audio != "undefined") //Fix phantomJs when calling the screenshot API , The audio object will be undefined
                this._audio = new Audio();else this._audio = {};
        }

        return this._audio;
    },
    _currentTrack: null,
    settings: {
        autoPlayNext: false,
        loopPlaylist: false,
        autoJumpToLastPosition: false,
        shufflePlaylist: false,
        volume: 1
    },
    getSettings: function getSettings(d, callback) {
        callback(null, this.settings);
    },
    setSettings: function setSettings(settings) {
        console.log('setSettings called');

        if (!settings) return;
        if (this.audio && this.settings) this.audio.volume = this.settings.volume;
        angular.extend(this.settings, settings);
        this.save();
    },
    resetSettingsToDefault: function resetSettingsToDefault() {
        audioPlayer.settings = {
            autoPlayNext: false,
            loopPlaylist: false,
            autoJumpToLastPosition: false,
            shufflePlaylist: false,
            volume: 1
        };
    },
    isStream: function isStream() {
        //Streams have an infinite time
        return !isFinite(audioPlayer.audio.duration);
    },
    isAndroid: function isAndroid() {
        var isAndroid = false;

        if (window.device && window.device.platform && window.device.platform.toLowerCase() === "android") {
            isAndroid = true;
        }

        return isAndroid;
    },

    retryAllowed: function retryAllowed() {
        var allowRetry = true;

        //Stalled seems to be called even when audio is working on Android, and we don't support background audio for Android
        //Only retry streams
        if (!audioPlayer.isStream()) {
            allowRetry = false;
        }

        return allowRetry;
    },
    retryAudio: function retryAudio() {
        console.warn('retryAudio');

        if (audioPlayer._interval.id == null) {
            audioPlayer._interval.id = setInterval(function () {
                audioPlayer.resumePlay();
            }, audioPlayer._interval.time);
        }
    },
    cancelRetry: function cancelRetry() {
        if (audioPlayer._interval.id != null) {
            clearInterval(audioPlayer._interval.id);
            audioPlayer._interval.id = null;
        }
    },
    resumePlay: function resumePlay() {
        if (!audioPlayer.audio.paused) {
            console.warn('restart audio', new Date());
            audioPlayer._allowPlay = true;
            audioPlayer.play(audioPlayer._currentTrack);
        }
    },
    init: function init() {
        var t = this;
        try {
            if (this.audio && this.audio.addEventListener) {
                this.audio.addEventListener('ended', function () {
                    t.triggerOnEvent('audioEnded', t._currentTrack);
                    if (t.settings.autoPlayNext) t.next();
                });
            }

            //Audio stopped playing midstream, possibly due to network loss
            if (this.audio && this.audio.addEventListener) {
                this.audio.addEventListener('stalled', function () {
                    console.warn('audio stalled', new Date());

                    if (audioPlayer.retryAllowed()) {
                        audioPlayer.retryAudio();
                    }
                });
            }

            //Error, such as a fail to play
            if (this.audio && this.audio.addEventListener) {
                this.audio.addEventListener('error', function () {
                    console.warn('audio error', new Date());

                    if (audioPlayer.retryAllowed()) {
                        audioPlayer.retryAudio();
                    }
                });
            }

            if (this.audio && this.audio.addEventListener) {
                this.audio.addEventListener('playing', function () {
                    console.warn('playing', new Date());
                    audioPlayer.cancelRetry();
                });
            }
        } catch (e) {
            console.warn('error', e);
        }

        var lastSavedTime = 0;
        if (this.audio && this.audio.addEventListener) this.audio.addEventListener('timeupdate', function () {
            if (t._currentTrack) t._currentTrack.lastPosition = t.audio.currentTime;

            if (Math.abs(lastSavedTime - t.audio.currentTime) > 5) {
                t.save();
                lastSavedTime = t.audio.currentTime;
            }

            t.triggerOnEvent('timeUpdate', {
                currentTime: t.audio.currentTime, duration: t.audio.duration,
                buffer: {
                    start: t.audio.buffered.length ? t.audio.buffered.start(0) : 0,
                    end: t.audio.buffered.length ? t.audio.buffered.end(0) : 0
                }
            });
        });

        if (this.audio && this.audio.addEventListener) this.audio.addEventListener('error', function (e) {
            t.triggerOnEvent('error', e);
        });

        var appContext = window.appContext;

        if (appContext != null && typeof appContext != 'undefined' && typeof appContext.currentApp != "undefined" && typeof appContext.currentApp.appId != "undefined") {
            /// get previously saved data
            var json = window.localStorage.getItem('audioPlayer');

            if (json != '{}') {
                try {
                    var rec = JSON.parse(json);

                    t.settings = rec.settings;
                    t.playlist = rec.playlist;
                    t._currentTrack = rec._currentTrack;
                    t.audio.volume = t.settings.volume;
                } catch (e) {
                    console.warn('audioPlayer localStorage error', e);
                }
            }
        } else console.warn("no app found for audioPlayer");
    },
    getCurrentTrack: function getCurrentTrack(d, callback) {
        // maintain PluginAPI format
        if (callback) callback(this._currentTrack);
        return this._currentTrack;
    },
    onEvent: function onEvent(callback) {
        var handler = function handler(e) {
            if (callback) callback(e.detail);
        };
        document.addEventListener('audioPlayer.onEvent', handler, false);
        return {
            clear: function clear() {
                document.removeEventListener('audioPlayer.onEvent', handler, false);
            }
        };
    },
    triggerOnEvent: function triggerOnEvent(event, data) {
        var event = new CustomEvent('audioPlayer.onEvent', { 'detail': { event: event, data: data } });
        document.dispatchEvent(event);
    },
    _tmrSave: null,
    save: function save() {

        /// save date with a delay
        if (this._tmrSave) clearTimeout(this._tmrSave);
        this._tmrSave = setTimeout(function () {
            try {
                var t = {
                    settings: audioPlayer.settings,
                    playlist: audioPlayer.playlist,
                    _currentTrack: audioPlayer._currentTrack
                };

                window.localStorage.setItem('audioPlayer', JSON.stringify(t));
            } catch (err) {
                var message = err.message ? err.message : '';

                console.error('Error with JSON.stringify. ', message);
            }
        }, 500);
    },
    play: function play(track) {
        //if the track is empty or has changed, allow play
        if (!audioPlayer._currentTrack || track && audioPlayer._currentTrack.url != track.url) {
            audioPlayer._allowPlay = true;
        }

        if (!audioPlayer._allowPlay) {
            return;
        }

        var trackType = typeof track === "undefined" ? "undefined" : _typeof(track);
        if (trackType == "string") track = { url: track };else if (trackType == "number") {

            var lookup = this.playlist.tracks[track];
            if (lookup) {
                this.playlist.lastIndex = track;
                track = lookup;
                this.save();
            } else return;
        } else if (!track) {
            if (this.audio.paused) {
                this.audio.play();
                this.triggerOnEvent('resume', { track: this._currentTrack });
            }
            return;
        }

        this.audio.src = track.url;
        this.audio.preload = 'auto';
        this._currentTrack = track;

        //played	Returns a TimeRanges object representing the played parts of the audio/video
        console.warn('this.audio.play()', new Date());
        this.audio.play();
        this.triggerOnEvent('play', { track: track });

        if (this.settings && this.settings.autoJumpToLastPosition && track.lastPosition) this.skip(track.lastPosition);

        if (track.startAt) this.skip(track.startAt);

        audioPlayer._allowPlay = false;
    },
    skip: function skip(value) {
        if (!this.audio) return;

        if (this.audio.currentTime + value < 0) this.audio.currentTime = 0;else if (this.audio.currentTime + value > this.audio.duration) this.audio.currentTime = this.audio.duration;else this.audio.currentTime += value;
        this.triggerOnEvent('skip', value);
    },
    pause: function pause() {
        audioPlayer.audio.pause();
        audioPlayer._allowPlay = true;
        audioPlayer.triggerOnEvent('pause');
    },
    isPaused: function isPaused(args, callback) {
        if (callback) callback(null, audioPlayer.audio.paused);
    },
    loopTrack: function loopTrack(val) {
        if (audioPlayer.audio) audioPlayer.audio.loop = val;
    },
    next: function next() {
        var track;
        if (audioPlayer.settings.shufflePlaylist) audioPlayer.playlist.lastIndex = Math.round((audioPlayer.playlist.tracks.length - 1) * Math.random());else audioPlayer.playlist.lastIndex++;

        if (audioPlayer.playlist.lastIndex >= audioPlayer.playlist.tracks.length) {
            if (audioPlayer.settings.loopPlaylist && audioPlayer.playlist.tracks.length) audioPlayer.playlist.lastIndex = 0;else {
                audioPlayer.playlist.lastIndex = audioPlayer.playlist.tracks.length - 1;
                return null;
            }
        }

        track = audioPlayer.playlist.tracks[audioPlayer.playlist.lastIndex];

        audioPlayer.save();

        audioPlayer.triggerOnEvent('next', { index: audioPlayer.playlist.lastIndex, track: track });
        if (track) audioPlayer.play(track);
        return track;
    },
    previous: function previous() {
        var track;
        if (audioPlayer.settings.shufflePlaylist) audioPlayer.playlist.lastIndex = Math.round((audioPlayer.playlist.tracks.length - 1) * Math.random());else audioPlayer.playlist.lastIndex--;

        if (audioPlayer.playlist.lastIndex < 0) {
            if (audioPlayer.settings.loopPlaylist && audioPlayer.playlist.tracks.length) audioPlayer.playlist.lastIndex = audioPlayer.playlist.tracks.length - 1;else {
                audioPlayer.playlist.lastIndex = 0;
                return null;
            }
        }

        track = audioPlayer.playlist.tracks[audioPlayer.playlist.lastIndex];

        audioPlayer.save();

        audioPlayer.triggerOnEvent('previous', { index: audioPlayer.playlist.lastIndex, track: track });
        if (track) audioPlayer.play(track);
        return track;
    },
    removeFromPlaylist: function removeFromPlaylist(index) {
        if (index < 0 || index >= audioPlayer.playlist.tracks.length) return;

        var track = audioPlayer.playlist.tracks.splice(index, 1);

        if (index == audioPlayer.playlist.lastIndex) audioPlayer.playlist.lastIndex = -1;else if (index < audioPlayer.playlist.lastIndex) audioPlayer.playlist.lastIndex--;

        audioPlayer.triggerOnEvent('removeFromPlaylist', { index: index, track: track, newPlaylist: audioPlayer.playlist });
    },
    addToPlaylist: function addToPlaylist(track) {
        audioPlayer.playlist.tracks.push(track);
        audioPlayer.save();

        audioPlayer.triggerOnEvent('addToPlaylist', { track: track, newPlaylist: audioPlayer.playlist });
    },
    setTime: function setTime(sec) {
        audioPlayer.audio.currentTime = sec;
        audioPlayer._currentTrack.lastPosition = audioPlayer.audio.currentTime;
        audioPlayer.save();
        audioPlayer.triggerOnEvent('timeUpdate', {
            currentTime: audioPlayer.audio.currentTime, duration: audioPlayer.audio.duration,
            buffer: {
                start: audioPlayer.audio.buffered.length ? audioPlayer.audio.buffered.start(0) : 0,
                end: audioPlayer.audio.buffered.length ? audioPlayer.audio.buffered.end(0) : 0
            }
        });
    },
    setVolume: function setVolume(percent) {
        if (percent < 0) percent = 0;else if (percent > 1 && percent <= 100) percent = percent / 100;

        if (audioPlayer.settings) audioPlayer.settings.volume = percent;
        if (audioPlayer.audio) audioPlayer.audio.volume = percent;
        audioPlayer.triggerOnEvent('volumeChange', { volume: percent });
        audioPlayer.save();
    },
    playlist: {
        tracks: [],
        lastIndex: -1
    },
    getPlaylist: function getPlaylist(d, callback) {
        callback(null, audioPlayer.playlist);
    }

};

if (typeof PluginAPI != "undefined" && !PluginAPI.prototype.mediaAPI) PluginAPI.prototype.mediaAPI = {
    audioPlayer: window.audioPlayer
};

window.addEventListener('load', function () {
    audioPlayer.init();

    if (typeof cordova !== 'undefined' && cordova.plugins && cordova.plugins.backgroundMode) {
        cordova.plugins.backgroundMode.setDefaults({
            text: 'Background mode enabled'
        });

        cordova.plugins.backgroundMode.enable();
        if (audioPlayer.isAndroid()) cordova.plugins.backgroundMode.disableWebViewOptimizations();
    }
});
"use strict";
/**
 * Created by Ayman on 7/30/2015.
 */

function NotificationsAPI(context) {
	this.context = context;
}

NotificationsAPI.prototype = {
	/*options:{
           title:
           message:
           okButton:{text:,type:}
 }*/
	alert: function (_alert) {
		function alert(_x, _x2) {
			return _alert.apply(this, arguments);
		}

		alert.toString = function () {
			return _alert.toString();
		};

		return alert;
	}(function (options, callback) {
		if (!options) {
			options = {};
		}
		if (!options.message) {
			callback("invalid parameter, messing message");
			return;
		}
		if (!options.okButton) {
			options.okButton = { text: "Ok" };
		}
		if (!options.okButton.text) {
			options.okButton.text = "Ok";
		}
		if (window.device && window.device.platform != "web" && typeof navigator != 'undefined' && navigator.notification && navigator.notification.alert) {
			navigator.notification.alert(options.message, // message
			callback, // callback
			options.title, // title
			options.okButton.text // buttonName
			);
		} else {
			alert(options.message);
			if (callback) callback();
		}
	}),

	/*options:{
               title:
               message:
               confirmButton:{text:,type:},
               cancelButton:{text:,type:}
 }*/
	confirm: function (_confirm) {
		function confirm(_x3, _x4) {
			return _confirm.apply(this, arguments);
		}

		confirm.toString = function () {
			return _confirm.toString();
		};

		return confirm;
	}(function (options, callback) {
		if (!options) {
			options = {};
		}
		if (!options.message) {
			callback("invalid parameter, missing message", null);
			return;
		}

		if (!options.confirmButton) {
			options.confirmButton = { text: "Confirm" };
		}
		if (!options.confirmButton.text) {
			options.confirmButton.text = "Confirm";
		}
		if (!options.cancelButton) {
			options.cancelButton = { text: "Cancel" };
		}
		if (!options.cancelButton.text) {
			options.cancelButton.text = "Cancel";
		}
		options.buttonLabels = [options.confirmButton.text, options.cancelButton.text];

		if (window.device && window.device.platform != "web" && typeof navigator != 'undefined' && navigator.notification && navigator.notification.confirm) {
			navigator.notification.confirm(options.message, // message
			callback, // callback to invoke with index of button pressed
			options.title, // title
			options.buttonLabels // buttonLabels
			);
		} else {
			var val = confirm(options.message);
			if (callback) callback(val);
		}
	}),

	prompt: function (_prompt) {
		function prompt(_x5, _x6) {
			return _prompt.apply(this, arguments);
		}

		prompt.toString = function () {
			return _prompt.toString();
		};

		return prompt;
	}(function (options, callback) {
		if (window.device && window.device.platform != "web" && typeof navigator != 'undefined' && navigator.notification && navigator.notification.prompt) {
			navigator.notification.prompt(options.message, // message
			callback, // callback to invoke
			options.title, // title
			options.buttonLabels, // buttonLabels
			options.defaultText // defaultText
			);
		} else {
			var val = prompt(options.message);
			if (callback) callback(val);
		}
	}),

	beep: function beep(options, callback) {
		console.log("calling NotificationsAPI.beep ...");
		if (window.device && window.device.platform != "web" && typeof navigator != 'undefined' && navigator.notification && navigator.notification.beep) {
			navigator.notification.beep(options.times);
			if (callback) callback();
		} else {
			if (callback) callback();
		}
	},

	vibrate: function vibrate(options, callback) {
		console.log("calling NotificationsAPI.vibrate ...");
		if (window.device && window.device.platform != "web" && typeof navigator != 'undefined' && navigator.notification && navigator.notification.vibrate) {
			navigator.notification.vibrate(options.milliseconds);
			if (callback) callback();
		} else {
			if (callback) callback();
		}
	}
};
"use strict";

/**
 * Created by Daniel on 3/30/2015.
 * only allow reads without secure api key
 * cache data here so that we dont hit the server for the same info over and over
 */
function appAPI(context) {
    this.appId = context.appId;
    this.liveMode = context.liveMode;
    this.appHost = context.endPoints.appHost;
    if (typeof CustomEvent == "undefined") console.warn("Browser doesnt support CustomEvent");
};

appAPI.prototype = {
    getPluginInstances: function getPluginInstances(data, callback) {
        var ds = new DatastoreAPI(this.appId, "pluginInstances", 1, this.liveMode, null);
        if (!data) data = {};

        //if(!data.pageSize)           data.pageSize = 10;

        if (!data.pageIndex) data.pageIndex = 1;

        var packet = {
            obj: {
                filter: { "$json.title": { "$regex": data.title != null ? data.title : '' } },
                page: data.pageIndex - 1,
                pageSize: data.pageSize // the plus one is to check if there are any more
                , withDynamicData: true,
                recordCount: true
            },
            tag: ''
        };

        ds.search(packet, function (err, results) {

            if (!err) {
                callback(null, { data: results.result, totals: results.totalRecord });
            }
        });
    }
};
'use strict';

if (typeof ActionItemsAPI == 'undefined') {

    window.ActionItemsAPI = function (context) {
        this.templateUrl = 'pages/share/actionBuilder.html';
        this.listTemplateUrl = window._appRoot + 'pages/templates/actionItemsListDialog.html';
        this.controller = 'actionItemsCtrl';
        this.context = context;
        this.init();
    };
}

ActionItemsAPI.prototype.init = function () {};

ActionItemsAPI.prototype.list = function (data, callback) {
    var openDialogOptions = {
        templateUrl: this.listTemplateUrl,
        controller: 'actionItemsListDialogCtrl',
        size: 'lg',
        data: data
    };

    window.openDialog(openDialogOptions, function (result) {
        if (callback) callback(null, result);
    });
};
ActionItemsAPI.prototype.openWebLink = function (url, openIn, callback) {
    if (url) {
        var windowReference = window.open(url, openIn, 'location=no'); /// TODO: only show if '_system'
        callback(!windowReference ? "failed to open window" : null);
        if (!windowReference) {
            ActionItemsAPI.prototype.popUpCtrlScope.show(url);
        }
    }
};

ActionItemsAPI.prototype.sendEmail = function (email, subject, body) {
    var url = "mailto:" + (email != null && email != '' ? email : '') + "?" + (subject != null && subject != '' ? 'subject=' + subject : '') + "&" + (body != null && body != '' ? 'body=' + body : '');
    window.open(url, "_system");
};

ActionItemsAPI.prototype.navigateToAddress = function (lat, lng) {
    if (lat && lng) {
        var url = "https://maps.google.com/?q=";
        if (window.device && window.device.platform != null) {
            if (window.device.platform.toLowerCase() == "android") {
                url = 'geo:?q=';
            } else if (window.device.platform.toLowerCase() == "ios") {
                url = 'maps://maps.apple.com?q=';
            }
        }

        window.open(url + lat + "," + lng, '_system', 'location=no,menubar=no,titlebar=no,toolbar=no');
    }
};

ActionItemsAPI.prototype.callNumber = function (phoneNumber) {
    if (phoneNumber) window.open('tel:' + phoneNumber + '', '_system', 'location=no,menubar=no,titlebar=no,toolbar=no');
};

ActionItemsAPI.prototype.sendSms = function (phoneNumber) {
    if (phoneNumber) {
        if (navigator.platform.indexOf("Android") != -1 || navigator.platform.indexOf("Linux") != -1 || navigator.platform == null) {
            var url = "sms:" + phoneNumber;
            window.open(url, "_system");
        } else if (navigator.platform.indexOf("iPhone") != -1 || navigator.platform.indexOf("iPad") != -1) {
            var url = "sms:" + phoneNumber;
            window.open(url, "_system");
        } else {
            console.error("This action can't be used on browser , it should be used on actual device");
        }
    }
};

ActionItemsAPI.prototype.linkToAppContent = function (instanceId, params) {
    var dsPluginInstance = new DatastoreAPI(appContext.currentApp.appId, "pluginInstances", 1, appContext.liveMode);

    var options = {};
    options.obj = {
        filter: { "$json.instanceId": instanceId },
        pageSize: 1,
        withDynamicData: true
    };
    dsPluginInstance.search(options, function (err, result) {
        if (result && result.length) {
            var instanceId = result[0].data.instanceId;
            var token = result[0].data._buildfire.pluginType.result[0].token;
            var folderName = result[0].data._buildfire.pluginType.result[0].folderName;
            var title = result[0].data.title;
            var pluginAPI = window.appContext.currentPlugin ? window.appContext.currentPlugin.pluginAPI : window.postMaster.launcherPluginAPI;
            if (pluginAPI) {
                pluginAPI.navigation.navigateTo({
                    pluginId: token,
                    instanceId: instanceId,
                    title: title,
                    folderName: folderName,
                    pushToHistory: true,
                    queryString: params ? params.queryString : null
                }, null);
            } else console.warn("Plugin API is empty");
        }
    });
};

ActionItemsAPI.prototype.purchase = function (productId, successMessage, errorMessage, navigateToPluginInstanceId, callback) {
    if (!bfUtils.isMobileDevice) {
        alert("This action can't be used on browser , it should be used on actual device");
        return;
    }
    if (typeof inAppPurchaseAPI == 'undefined') {
        console.error('inAppPurchaseAPI is undefined');
        return;
    }
    var purchaseResultCallback = function purchaseResultCallback(err, purchase) {
        if (!err) {
            if (purchase && purchase.isApproved) {
                var options = {
                    data: {
                        title: ' ',
                        body: successMessage,
                        disableCancel: true
                    }
                };

                window.openDialog(options, function () {});

                if (navigateToPluginInstanceId) {
                    ActionItemsAPI.prototype.linkToAppContent(navigateToPluginInstanceId);
                }
            }
        } else {
            var options = {
                data: {
                    title: ' ',
                    body: errorMessage,
                    disableCancel: true
                }
            };

            window.openDialog(options, function () {});
        }
        callback(err, purchase);
    };

    var prodObj = { productId: productId };
    inAppPurchaseAPI.checkProduct(prodObj, function (err, product) {
        if (err) {
            console.error("error while checking product", err);
        }
        if (product && (product.state == 'approved' || product.owned)) {
            if (navigateToPluginInstanceId) {
                ActionItemsAPI.prototype.linkToAppContent(navigateToPluginInstanceId);
            }
            callback(null, { product: product, isApproved: true });
        } else {
            inAppPurchaseAPI.purchase(prodObj, purchaseResultCallback);
        }
    });
};

ActionItemsAPI.prototype.execute = function (actionItem, callback) {

    var actionSupportsCallback = false;
    switch (actionItem.action) {
        case 'linkToApp':
            this.linkToAppContent(actionItem.instanceId, { queryString: actionItem.queryString });
            break;
        case 'linkToWeb':
            actionSupportsCallback = true;
            this.openWebLink(actionItem.url, actionItem.openIn, callback);
            break;
        case 'sendEmail':
            this.sendEmail(actionItem.email, actionItem.subject, actionItem.body);
            break;
        case 'callNumber':
            this.callNumber(actionItem.phoneNumber);
            break;
        case 'sendSms':
            this.sendSms(actionItem.phoneNumber);
            break;
        case 'navigateToAddress':
            this.navigateToAddress(actionItem.lat, actionItem.lng);
            break;
        case 'linkToSocialGoogle':
            this.openWebLink(actionItem.url, "_system");
            break;
        case 'linkToSocialFacebook':
            this.openWebLink(actionItem.url, "_system");
            break;
        case 'linkToSocialInstagram':
            this.openWebLink(actionItem.url, "_system");
            break;
        case 'linkToSocialTwitter':
            this.openWebLink(actionItem.url, "_system");
            break;
        case 'linkToSocialLinkedIn':
            this.openWebLink(actionItem.url, "_system");
            break;
        case 'purchase':
            actionSupportsCallback = true;
            this.purchase(actionItem.productId, actionItem.successMessage, actionItem.successMessage, actionItem.instanceId, callback);
            break;
    }
    if (!actionSupportsCallback) {
        callback(null, true);
    }
};

if (typeof $app != "undefined") $app.controller('actionItemsListDialogCtrl', ['$scope', '$data', '$dialog', function ($scope, $data, $dialog) {
    $scope.actionItems = $data.actionItems;
    $scope.executeItem = true;
    $scope.close = function () {
        $dialog.close(null);
    };
    if ($data.options && $data.options.executeItem) $scope.executeItem = $data.options.executeItem;
    $scope.openActionItem = function (actionItem) {
        if ($scope.executeItem) {
            var pluginAPI = window.appContext.currentPlugin ? window.appContext.currentPlugin.pluginAPI : window.postMaster.launcherPluginAPI;
            pluginAPI.actionItems.execute(actionItem, function (err, result) {
                $dialog.close(actionItem);
            });
        } else $dialog.close(actionItem);
    };
}]);
'use strict';

function PluginInstanceAPI(context) {
    this.templateUrl = 'pages/plugins/pluginInstanceDialog/pluginInstanceDialog.html';
    this.controller = 'pluginInstanceDialog';
    this.appId = context.appId;
    this.liveMode = context.liveMode;
    this.appHost = window.siteConfig.endPoints.appHost;
    var dContext = JSON.parse(JSON.stringify(context)); // make a copy
    dContext.pluginId = "pluginInstances";
    dContext.instanceId = 1;
    this.ds = new DatastoreAPI(dContext);
};

PluginInstanceAPI.prototype = {
    showDialog: function showDialog(data, callback) {

        if (!window.openDialog) {
            console.error("openDialog isnt defined");
            return;
        }

        var openDialogOptions = {
            templateUrl: this.templateUrl,
            controller: this.controller,
            size: 'lg',
            data: data
        };

        window.openDialog(openDialogOptions, function (result) {
            if (callback) callback(null, result);
        });
    },
    get: function get(instanceId, callback) {
        /*var params = {};
         if (ids instanceof Array) {
         params.ids = ids.join(", ")
         } else
         params.ids = ids;
          var url = this._createReadUrl();
          this._httpGet(url, params, function (err, result) {
         if (err)
         callback(err, null);
         else
         callback(null, result);
         });*/

        var options = {};
        options.obj = {
            filter: { "$json.instanceId": instanceId },
            pageSize: 1,
            withDynamicData: true
        };

        this.ds.search(options, function (err, result) {
            if (!err) {
                if (result && result.length) {
                    callback(null, result[0].data);
                } else callback(null);
            } else callback(err, null);
        });
    },
    _createReadUrl: function _createReadUrl() {
        return this.appHost + "/api/appPluginInstances/getByIds/" + this.appId;
    },
    _httpGet: function _httpGet(url, params, callback) {
        bfUtils.http.get(url, { params: params }).success(function (data) {
            callback(null, data);
        }).error(function (err) {
            callback(err);
        });
    },
    search: function search(options, callback) {

        var filter;
        if (options.title) filter = { "$json.title": { "$regex": options.title, "$options": "-i" } };
        var packet = {
            obj: {
                filter: filter,
                page: options.pageIndex,
                pageSize: options.pageSize // the plus one is to check if there are any more
                , withDynamicData: true,
                recordCount: true
            },
            tag: ''
        };

        this.ds.search(packet, callback);
    }
};
"use strict";

var deviceAPI = {
    calendar: {
        /*
        * event {
        * title
        * ,location
        * ,notes
        * ,startDate
        * ,endDate
        * ,options: {
        *    ,firstReminderMinutes = 120; // default is 60, pass in null for no reminder (alarm)
             ,secondReminderMinutes = 5;
             ,recurrence = "monthly"; // supported are: daily, weekly, monthly, yearly
             ,recurrenceEndDate = new Date(2015,6,1,0,0,0,0,0); // leave null to add events into infinity and beyond
        *   }
        * }
        * */
        addEvent: function addEvent(event, callback) {
            var cal;

            if (window.plugins && window.plugins.calendar) cal = window.plugins.calendar;

            if (!cal) {
                console.warn("cannot complete action add event to calendar. so fake it");
                if (window.location.protocol.indexOf('http') >= 0) alert('Adding to calendar requires native app.');else console.error('Calendar feature not installed');
                return;
            }

            if (!(event.startDate instanceof Date)) event.startDate = new Date(event.startDate); // beware: month 0 = january, 11 = december

            if (!(event.endDate instanceof Date)) event.endDate = new Date(event.endDate); // beware: month 0 = january, 11 = december

            var success = function success(message) {
                callback(null, message);
            };
            var error = function error(message) {
                callback(message);
            };

            /*
            var calOptions = cal.getCalendarOptions(); // grab the defaults
            calOptions.firstReminderMinutes = 120; // default is 60, pass in null for no reminder (alarm)
            calOptions.secondReminderMinutes = 5;
            calOptions.recurrence = "daily"; // supported are: daily, weekly, monthly, yearly
            calOptions.recurrenceEndDate = new Date(2025, 4, 15, 19, 30, 0, 0, 0); //
            */

            if (event.options) {
                var calOptions;
                calOptions = cal.getCalendarOptions();
                calOptions.firstReminderMinutes = event.options.firstReminderMinutes || calOptions.firstReminderMinutes;
                calOptions.secondReminderMinutes = event.options.secondReminderMinutes || calOptions.secondReminderMinutes;
                calOptions.recurrence = event.options.recurrence || calOptions.recurrence;
                if (event.options.recurrenceEndDate) calOptions.recurrenceEndDate = new Date(event.options.recurrenceEndDate);
                cal.createEventWithOptions(event.title, event.location, event.notes, event.startDate, event.endDate, calOptions, success, error);
            } else {

                cal.createEvent(event.title, event.location, event.notes, event.startDate, event.endDate, success, error);
            }
        }
    },
    share: function share(messageObj, callback) {
        if (window.plugins && window.plugins.socialsharing) {
            window.plugins.socialsharing.share(messageObj.text, messageObj.subject, messageObj.image, messageObj.link);
            callback(null, true);
        } else {
            console.warn("device sharing plugin not found. defaulting to email sending");
            window.location = 'mailto:?subject=' + encodeURIComponent(messageObj.subject) + '&body=' + encodeURIComponent(messageObj.text + ' ' + messageObj.link);
            callback(null, true);
        }
    },
    onAppBackgrounded: function onAppBackgrounded(callback) {
        document.addEventListener('deviceAppBackgrounded', callback, false);
    },
    onAppResumed: function onAppResumed(callback) {
        document.addEventListener('deviceAppResumed', callback, false);
    }
};
"use strict";
/**
 * Created by Daniel on 3/30/2015.
 * only allow reads without secure api key
 * cache data here so that we dont hit the server for the same info over and over
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function HistoryAPI(appId, pluginId, instanceId, liveMode) {
    if ((typeof appId === "undefined" ? "undefined" : _typeof(appId)) == "object") {
        var config = appId;
        this.appId = config.appId;
        this.pluginId = config.pluginId;
        this.instanceId = config.instanceId;
        this.liveMode = config.liveMode;
    } else {
        this.appId = appId;
        this.pluginId = pluginId;
        this.instanceId = instanceId;
        this.liveMode = liveMode;
    }
}

HistoryAPI.prototype = {
    historyItems: [],
    push: function push(pushedItem, callback) {
        if (typeof emulatorSync === 'undefined') {
            // we are on the correct side
            if (pushedItem.source != "plugin") {
                // remove all breadcrumbs added by the current plugin when pushing history for a new plugin
                var pluginBreadcrumbIndex = -1;
                if (this.historyItems.length > 1) {
                    for (var i = 1; i < this.historyItems.length; i++) {
                        if (this.historyItems[i].source == "plugin") {
                            // keep launcher own breadcrumbs, remove only other plugin breadcrumbs
                            if (this.historyItems[i - 1].source == "control") {
                                pluginBreadcrumbIndex = i;
                                break;
                            }
                        }
                    }
                    if (pluginBreadcrumbIndex >= 0) {
                        this.historyItems.splice(pluginBreadcrumbIndex);
                    }
                }
            }
            pushedItem.uid = new Date().getTime();
            this.historyItems.push(pushedItem);
            var onPushEvent = new CustomEvent('historyOnPush', { detail: { pushedItem: pushedItem } });
            document.dispatchEvent(onPushEvent);
            var onUpdateEvent = new CustomEvent('historyOnUpdate', { detail: { historyItems: this.historyItems } });
            document.dispatchEvent(onUpdateEvent);
        } else {
            // no history items here. delegate call to the app side
            var packet = new Packet(null, 'history.pushAppHistory', pushedItem);
            emulatorSync.sendMessage(packet);
        }

        if (callback) {
            callback(null, true);
        }
        return this;
    },
    get: function get(options, callback) {
        if (options && options.pluginBreadcrumbsOnly) {
            var pluginBreadcrumbs = [];
            for (var i = 0; i < this.historyItems.length; i++) {
                if (this.historyItems[i].source == "plugin") {
                    pluginBreadcrumbs.push(this.historyItems[i]);
                }
            }
            callback(null, pluginBreadcrumbs);
        } else {
            callback(null, this.historyItems);
        }
        return this;
    },
    getNext: function getNext(breadcrumb) {
        var nextBreadcrumb = null;
        if (this.historyItems) {
            for (var i = 0; i < this.historyItems.length; i++) {
                if (this.historyItems[i] == breadcrumb || this.historyItems[i].uid == breadcrumb.uid) {
                    if (i < this.historyItems.length) {
                        nextBreadcrumb = this.historyItems[i + 1];
                    }
                    break;
                }
            }
        }
        return nextBreadcrumb;
    },
    pop: function pop(breadcrumb, callback) {
        if (typeof emulatorSync === 'undefined') {
            // we are on the correct side
            if (!breadcrumb && this.historyItems) {
                if (this.historyItems.length > 1) {
                    var lastBreadcrumb = this.historyItems[this.historyItems.length - 1];
                    if (lastBreadcrumb && lastBreadcrumb.source == "plugin") {
                        breadcrumb = this.historyItems[this.historyItems.length - 2]; // pop to the previous one
                    }
                } else {
                    if (this.historyItems[0] && this.historyItems[0].source == "plugin") {
                        breadcrumb = this.historyItems[0];
                    }
                }
            }
            if (breadcrumb) {
                var breadcrumbIndex = -1;
                var isPluginTopBreadcrumb = false; // if this is the top level breadcrumb within the same plugin instance
                for (var i = 0; i < this.historyItems.length; i++) {
                    if (this.historyItems[i] == breadcrumb || this.historyItems[i].uid == breadcrumb.uid) {
                        breadcrumbIndex = i;
                        if (i + 1 < this.historyItems.length && this.historyItems[i + 1].source == "plugin") {
                            isPluginTopBreadcrumb = true;
                        }
                        break;
                    }
                }
                if (breadcrumbIndex >= 0 && breadcrumbIndex <= this.historyItems.length) {
                    this.historyItems.splice(breadcrumbIndex + 1);
                }
                var onPopEvent = new CustomEvent('historyOnPop', { detail: { poppedItem: breadcrumb } });
                document.dispatchEvent(onPopEvent);
                var onUpdateEvent = new CustomEvent('historyOnUpdate', { detail: { historyItems: this.historyItems } });
                document.dispatchEvent(onUpdateEvent);
                if ((isPluginTopBreadcrumb || breadcrumb.source == "plugin") && postMaster) {
                    var packet = new Packet(null, "history.triggerOnPop", breadcrumb);
                    if (postMaster.widgetPluginAPI) {
                        postMaster.widgetPluginAPI.sendMessage(null, packet);
                    } else if (postMaster.launcherPluginAPI) {
                        postMaster.launcherPluginAPI.sendMessage(null, packet);
                    }
                }
            } else {
                if (callback) {
                    callback("breadcrumb not found");
                    return this;
                }
            }
        } else {
            // no history items here. delegate call to the app side
            var packet = new Packet(null, 'history.popAppHistory', breadcrumb);
            emulatorSync.sendMessage(packet);
        }
        if (callback) {
            callback(null, true);
        }
        return this;
    },
    popToHome: function popToHome() {
        if (this.historyItems && this.historyItems.length > 1) {
            for (var i = 1; i < this.historyItems.length; i++) {
                if (this.historyItems[i].source == 'control') {
                    this.pop(this.historyItems[i - 1]);
                }
            }
        }
    },
    popToPlugin: function popToPlugin() {
        if (this.historyItems && this.historyItems.length > 1) {
            for (var i = this.historyItems.length - 1; i > 1; i--) {
                if (this.historyItems[i].source == 'plugin') {
                    this.pop(this.historyItems[i - 1]);
                } else {
                    break;
                }
            }
        }
    },
    clear: function clear(options, callback) {
        var poppedItem = this.historyItems[0];
        this.historyItems.splice(0);
        if (callback) {
            callback(null);
        }
        var onUpdateEvent = new CustomEvent('historyOnUpdate', { detail: { historyItems: this.historyItems } });
        document.dispatchEvent(onUpdateEvent);
        if (poppedItem) {
            var onPopEvent = new CustomEvent('historyOnPop', { detail: { poppedItem: poppedItem } });
            document.dispatchEvent(onPopEvent);
        }
        return this;
    },
    triggerOnPop: function triggerOnPop(poppedItem) {
        var onPopEvent = new CustomEvent('historyOnPop', { detail: { poppedItem: poppedItem } });
        document.dispatchEvent(onPopEvent);
        return this;
    },
    triggerOnUpdate: function triggerOnUpdate(historyItems) {
        this.historyItems = historyItems;
        var onUpdateEvent = new CustomEvent('historyOnUpdate', { detail: { historyItems: historyItems } });
        document.dispatchEvent(onUpdateEvent);
        return this;
    },
    onUpdate: function onUpdate(callback) {
        var handler = function handler(e) {
            if (callback) callback({ historyItems: e.detail.historyItems });
        };
        document.addEventListener('historyOnUpdate', handler, false);
        return {
            clear: function clear() {
                document.removeEventListener('historyOnUpdate', handler, false);
            }
        };
    },
    onPop: function onPop(callback) {
        var handler = function handler(e) {
            if (callback) callback(e.detail);
        };
        document.addEventListener('historyOnPop', handler, false);
        return {
            clear: function clear() {
                document.removeEventListener('historyOnPop', handler, false);
            }
        };
    },
    onPush: function onPush(callback) {
        var handler = function handler(e) {
            if (callback) callback({ historyItems: e.detail.historyItems, pushedItem: e.detail.pushedItem });
        };
        document.addEventListener('historyOnPush', handler, false);
        return {
            clear: function clear() {
                document.removeEventListener('historyOnPush', handler, false);
            }
        };
    }
};
"use strict";
/**
 * Created by Daniel on 3/30/2015.
 * this class is whats used for the plugin frame to communicate with he parent app shell
 * this only allows certain interactions to occur for security purposes
 * all functionality should return *this* and accept a callback
 * *** this also handel's messages sent from the CP
 */

function Packet(id, cmd, data, error) {
	this.id = id;
	this.cmd = cmd;
	this.data = data;
	this.error = error;
	this.instanceId;
}
var pluginCount = 0;

if (typeof logger == "undefined") var logger = {
	log: function log() {}
}; //fail safe

function PluginAPI(iFrameId, appId, pluginId, instanceId, liveMode, datastoreWriteKey, type) {
	pluginCount++;
	this.datastore = this.analytics = this.appearance = null;
	this.iFrameId = iFrameId;
	this.iFrame = document.getElementById(iFrameId);
	this.init(appId, pluginId, instanceId, liveMode, datastoreWriteKey, type);
}

PluginAPI.prototype = {
	getContentWindow: function getContentWindow() {
		//if(!this.iFrame)return null;

		//if(this.iFrame && !this.iFrame.contentWindow)
		this.iFrame = document.getElementById(this.iFrameId);

		if (this.iFrame) return this.iFrame.contentWindow;else return null;
	},
	debugTag: null,
	init: function init(appId, pluginId, instanceId, liveMode, datastoreWriteKey, type) {

		if (!window.appContext || !window.appContext.currentApp) {
			console.error('invalid appContext cant create pluginAPI');
			return;
		}

		var cpDomain = window.appContext && window.appContext.currentApp && window.appContext.currentApp.config && window.appContext.currentApp.config.cpDomain ? window.appContext.currentApp.config.cpDomain : window.siteConfig.endPoints.appHost;

		this.context = {
			appId: appId,
			pluginId: pluginId,
			instanceId: instanceId,
			liveMode: liveMode || 0,
			endPoints: window.siteConfig.endPoints,
			cpDomain: cpDomain,
			device: window.device,
			deviceId: typeof push != "undefined" ? push.deviceId : null,
			debugTag: this.debugTag,
			datastoreWriteKey: datastoreWriteKey || undefined,
			type: type,
			appTheme: PluginAPI.appTheme,
			configType: PluginAPI.configType
		};

		var currentAppManifestString = localStorage.getItem("currentAppManifest");
		if (currentAppManifestString) {
			var currentAppManifest = null;
			try {
				currentAppManifest = JSON.parse(currentAppManifestString);
			} catch (err) {
				console.error("bad currentAppManifest", err);
			}
			this.context.offlineModeEnabled = currentAppManifest.offlineModeEnabled;
		}

		if (!this.context.device) {
			this.context.device = {
				platform: 'web'
			};
		}

		if (typeof AppearanceAPI != "undefined") this.appearance = new AppearanceAPI(this.context);
		if (typeof DatastoreAPI != "undefined") this.datastore = new DatastoreAPI(this.context);
		if (typeof UserDatastoreAPI != "undefined") this.userData = new UserDatastoreAPI(this.context);
		if (typeof AnalyticsAPI != "undefined") {
			this.analytics = new AnalyticsAPI(this.context);
		}
		if (typeof ImageLibAPI != "undefined") this.imageLib = new ImageLibAPI(this.context);
		if (typeof ColorLibAPI != "undefined") {
			this.colorLib = new ColorLibAPI(this.context);
			this.colorLib.onChange(function (data) {
				t.sendMessage(null, new Packet(null, 'colorLib._triggerOnChange', data));
			});
		}
		if (typeof appAPI != "undefined") this.appAPI = new appAPI(this.context);
		if (typeof ActionItemsAPI != "undefined") this.actionItems = new ActionItemsAPI(this.context);
		if (typeof NotificationsAPI != "undefined") this.notificationsAPI = new NotificationsAPI(this.context);
		if (typeof PopupLibAPI != "undefined") this.notificationsAPI = PopupLibAPI;
		if (typeof HistoryAPI != "undefined") this.history = new HistoryAPI(this.context);
		if (typeof PluginInstanceAPI != "undefined") this.pluginInstances = new PluginInstanceAPI(this.context);
		if (typeof inAppPurchaseAPI != "undefined") {
			this.inAppPurchase = inAppPurchaseAPI;
		}
		if (typeof barcodeScannerAPI != "undefined") {
			this.barcodeScanner = barcodeScannerAPI;
		}

		if (typeof PublicDatastoreAPI != "undefined") this.publicData = new PublicDatastoreAPI(this.context);
		if (typeof iBeaconAPI != "undefined") this.iBeacon = iBeaconAPI;

		if (typeof localStorageAPI != "undefined") this.localStorage = localStorageAPI;

		if (typeof LocalNotificationsAPI != "undefined") {
			this.localNotifications = new LocalNotificationsAPI(this.context);
		}
		if (typeof DeepLinkAPI != "undefined") this.deepLink = new DeepLinkAPI(this.context);

		if (typeof deviceAPI != "undefined") {
			this.device = deviceAPI;
			this.device.onAppBackgrounded(function (data) {
				t.sendMessage(null, new Packet(null, 'device.triggerOnAppBackgrounded', data.detail));
			});
			this.device.onAppResumed(function (data) {
				t.sendMessage(null, new Packet(null, 'device.triggerOnAppResumed', data.detail));
			});
		}
		if (typeof geoAPI != "undefined") this.geo = geoAPI;
		if (typeof inputAPI != "undefined") this.input = inputAPI;
		if (typeof bluetoothAPI != "undefined") this.bluetooth = bluetoothAPI;
		if (typeof cameraAPI != "undefined") this.camera = cameraAPI;
		if (typeof fileManagerAPI != "undefined") this.fileManager = fileManagerAPI;

		if (typeof PushNotificationsAPI != "undefined") this.pushNotifications = new PushNotificationsAPI(this.context);

		if (typeof FirebaseAPI != "undefined") this.firebase = new FirebaseAPI(this.context);

		if (typeof authAPI != "undefined") {
			this.auth = authAPI;
			this.auth.init(this.context);
			var t = this;
			this.auth.onLogin(function (data) {
				t.sendMessage(null, new Packet(null, 'auth.triggerOnLogin', data.detail));
			});
			this.auth.onLogout(function () {
				t.sendMessage(null, new Packet(null, 'auth.triggerOnLogout'));
			});
		}

		var t = this;
		this.mediaAPI = new Object();
		if (typeof audioPlayer != "undefined") {
			this.mediaAPI.audioPlayer = audioPlayer;

			this.mediaAPI.audioPlayer.onEvent(function (e) {
				t.sendMessage(null, new Packet(null, 'services.media.audioPlayer.triggerOnEvent', e));
			});
		}

		/*****************************************************/
		///should be placed somewhere else
		this.analytics.trackActionCommand = function (obj, callback) {
			if (!obj) {
				return false;
			}
			return t.analytics.trackAction(obj.value, obj.metadata, callback);
		};
		this.analytics.trackViewCommand = function (obj, callback) {
			if (!obj) {
				return false;
			}
			return t.analytics.trackView(obj.value, obj.metadata, callback);
		};
		/*****************************************************/

		this.navigation.pluginAPI = this;
	},
	postMessageHandler: function postMessageHandler(e) {

		if (!this.iFrameId) return false;

		var req = undefined;

		try {
			req = e.packet || JSON.parse(e.data);
		} catch (err) {
			console.warn('error parsing post message data.');
			return;
		}

		if (!req || !req.cmd || !req.cmd.split) return;

		if (e.source != this.getContentWindow() && req.fid != this.iFrameId ///dont catch your own //e.source != window.parent && if buidfire.js sends back your id then its ok
		&& this.context.instanceId != req.instanceId) {
			return;
		} //none of hour business, ignore


		//console.log(this.tag, ' received << ', e.data, window.location.href);

		var t = this;
		var callback = function callback(err, result) {
			if (err) console.warn(e.data, err);
			var packet = new Packet(req.id, req.cmd, result, err);
			t.sendMessage(null, packet);
		};

		/// prone to error but thats ok
		var sequence = req.cmd.split('.');
		var obj = this;
		var parent = this;
		for (var i = 0; i < sequence.length; i++) {
			if (i > 0) parent = obj;
			if (obj[sequence[i]]) obj = obj[sequence[i]];else {
				return true; // cant handle request but request was for me
			}
		}
		//console.log("PluginAPI", this.tag, "execute command", req.cmd);
		obj.apply(parent, [req.data, callback]);
		return true;
	},
	sendMessage: function sendMessage(destination, packet) {
		//if(!destination)
		destination = this.getContentWindow();

		if (destination && destination.postMessage) {
			//if (typeof(packet) != "string")	packet = JSON.stringify(packet);
			//console.log(this.tag, ' sent >> ', packet, window.location.href);
			packet = JSON.parse(JSON.stringify(packet)); // avoid 'object could not be cloned'
			destination.postMessage(packet, '*');
		}
	},
	getContext: function getContext(data, callback) {
		//ignore data but must keep the same format
		callback(null, this.context);
		return this;
	},
	navigation: {
		displayPopUpInstructions: function displayPopUpInstructions() {
			window.location.hash = '/popUp';
		},
		navigateTo: function navigateTo(pluginData, callback) {
			if (!(pluginData.pushToHistory === false)) {
				pluginData.pushToHistory = true;
			}
			var samePluginNavigation = false;
			var hash = '/pluginContainer/' + pluginData.pluginId + '/' + pluginData.instanceId + '/' + encodeURIComponent(pluginData.title) + '/' + pluginData.folderName + '/' + pluginData.pushToHistory; // + (pluginData.query  ? ('?' + pluginData.query) : '' );
			var historyAPI = new HistoryAPI();
			if (!pluginData.pushToHistory) {
				historyAPI.popToHome(); // clear to start new breadcrumbs
			}
			if (historyAPI.historyItems.length == 0) {
				historyAPI.push({ label: "Home", options: { pluginData: undefined }, source: "home" });
			}
			if (historyAPI.historyItems.length == 1 && postMaster.launcherPluginAPI && pluginData.instanceId == postMaster.launcherPluginAPI.context.instanceId && pluginData.pluginId == postMaster.launcherPluginAPI.context.pluginId) {
				// already on home
			} else {
				var currentBreadcrumb = historyAPI.historyItems[historyAPI.historyItems.length - 1];
				if (currentBreadcrumb.source == 'control') {
					if (pluginData.instanceId != currentBreadcrumb.options.pluginData.instanceId || pluginData.pluginId != currentBreadcrumb.options.pluginData.pluginId) historyAPI.push({
						label: decodeURIComponent(pluginData.title),
						options: { pluginData: pluginData, context: window.location.href },
						source: "control"
					});else {
						samePluginNavigation = true;
					}
				} else {

					var label;
					try {
						label = decodeURIComponent(pluginData.title);
					} catch (e) {
						console.error('BAD Title', pluginData.title, e);
						label = 'TITLE';
					}

					historyAPI.push({
						label: label,
						options: { pluginData: pluginData, context: window.location.href },
						source: "control"
					});
				}
			}

			/// push any data that the user wants to send to the next plugin in here
			/// the pluginCtrl will pop it and pass it along to the next plugin
			if (pluginData && pluginData.queryString) window.pluginControllerHelper.pluginPassThroughqueryString = pluginData.queryString;

			if (pluginData && (pluginData.dontTriggerHashChangeEvent || samePluginNavigation)) cpSync.navigation.silentNavigation(hash);else window.location.hash = hash;
			if (callback) callback(null, { status: 'completed' });
		},

		// params:
		// .instanceId
		// .data (optional)
		navigateToPluginInstance: function navigateToPluginInstance(params, callback) {
			var that = this;

			if (!params || !params.instanceId) {
				callback("Invalid parameters. Need to pass instanceId.");
				return;
			}

			var dsPluginInstance = new DatastoreAPI(appContext.currentApp.appId, "pluginInstances", 1, appContext.liveMode);
			var options = {};
			options.obj = {
				filter: { "$json.instanceId": params.instanceId },
				pageSize: 1,
				withDynamicData: true
			};
			dsPluginInstance.search(options, function (err, result) {
				if (result && result.length) {
					var token = result[0].data._buildfire.pluginType.result[0].token;
					var folderName = result[0].data._buildfire.pluginType.result[0].folderName;
					var title = result[0].data.title;
					//var pluginAPI =  window.appContext.currentPlugin  ? window.appContext.currentPlugin.pluginAPI :window.postMaster.launcherPluginAPI ;
					//if(pluginAPI) {
					that.navigateTo({
						pluginId: token,
						instanceId: params.instanceId,
						title: title,
						folderName: folderName,
						pushToHistory: false,
						query: params.queryString
					}, callback);
					//}
				}
			});
		},
		navigateToAppearance: function navigateToAppearance(options) {
			if (options && options.dontTriggerHashChangeEvent) cpSync.navigation.silentNavigation('/appearanceSample');else window.location.hash = '/appearanceSample';
		},
		navigateHome: function navigateHome(options) {
			if (options && options.dontTriggerHashChangeEvent) cpSync.navigation.silentNavigation('/');else window.location.hash = '/';
			var historyAPI = new HistoryAPI();
			historyAPI.clear(); // clear to start new breadcrumbs
			historyAPI.push({ label: "Home", options: { pluginData: undefined }, source: "home" });
		},
		navigateBack: function navigateBack() {
			var historyAPI = new HistoryAPI();
			var me = this;
			if (historyAPI.historyItems && historyAPI.historyItems.length > 1) {
				var poppedBreadcrumb = historyAPI.historyItems[historyAPI.historyItems.length - 1];
				var previousBreadcrumb = historyAPI.historyItems[historyAPI.historyItems.length - 2];
				if (previousBreadcrumb && previousBreadcrumb.options) {
					switch (previousBreadcrumb.source) {
						case 'control':
							var pluginData = null;
							if (poppedBreadcrumb.source == 'plugin') {
								historyAPI.pop(previousBreadcrumb);
								if (previousBreadcrumb.options.pluginData) {
									pluginData = JSON.parse(JSON.stringify(previousBreadcrumb.options.pluginData)); // clone pluginData
									me.navigateTo(pluginData);
								}
							} else {
								// navigate then pop when navigating from a plugin to another to compare that plugin has changed
								if (previousBreadcrumb.options.pluginData) {
									pluginData = JSON.parse(JSON.stringify(previousBreadcrumb.options.pluginData)); // clone pluginData
									me.navigateTo(pluginData);
								}
								historyAPI.pop(previousBreadcrumb);
							}
							break;
						case 'plugin':
							if (poppedBreadcrumb.source == 'control') {
								// must be launcher breadcrumbs
								if (window.location.protocol.indexOf('http') < 0) {
									// on device just bring the user back to the launcher plugin as is
									historyAPI.pop(previousBreadcrumb);
									window.location.hash = '/';
								} else {
									// if your on CP reset the launcher plugin so that the emulator is in sync with the reloaded content area
									historyAPI.clear(); // clear to start new breadcrumbs
									historyAPI.push({ label: "Home", options: { pluginData: undefined }, source: "home" });
									window.location.hash = '/';
								}
							} else {
								historyAPI.pop(previousBreadcrumb);
							}
							break;
						case 'home':
							if (poppedBreadcrumb.source == 'plugin') {
								// still on home
								historyAPI.pop(previousBreadcrumb);
								break;
							}
						// continue to default
						default:
							historyAPI.clear(); // clear to start new breadcrumbs
							historyAPI.push({ label: "Home", options: { pluginData: undefined }, source: "home" });
							window.location.hash = '/';
					}
				}
			} else {
				historyAPI.clear(); // clear to start new breadcrumbs
				historyAPI.push({ label: "Home", options: { pluginData: undefined }, source: "home" });
				window.location.hash = '/';
			}
		},
		scrollTop: function scrollTop(val, callback) {
			document.body.scrollTop = val ? val : 0;
			if (callback) callback();
		},
		navigateEmulator: function navigateEmulator() {
			if (!cordova || !cordova.file || !cordova.file.applicationDirectory) {
				console.log("Cant load emulator bc cordova.file.applicationDirectory is undefined");
				return;
			}

			if (!window.appContext || !window.appContext.environment) {
				console.log("Cant load emulator bc window.appContext.environment is undefined");
				return;
			}

			if (window.location.href.indexOf('http://') < 0) window.location.href = cordova.file.applicationDirectory + 'www/emulator/login.html?env=' + window.appContext.environment + '&lastUrl=' + encodeURIComponent(window.location.href);
		},
		navigateToApp: function navigateToApp(options) {
			/// dont expose. used internally
			window.location.search = '?env=' + window.appContext.environment + '&appId=' + options.appId + '&mode=' + window.appContext.currentApp.liveMode + '&lastUrl=' + encodeURIComponent(window.location.href);
		}
	},
	messaging: {
		triggerOnNewControlMessage: function triggerOnNewControlMessage(message) {
			console.warn('unhandled message [onNewControlMessage]');
		},

		triggerOnNewWidgetMessage: function triggerOnNewWidgetMessage(message) {
			console.warn('unhandled message [onNewWidgetMessage]');
		}

	},
	spinner: {
		show: function show(data, callback) {

			if (window.spinner) window.spinner.show();
			if (callback) callback();
		},
		hide: function hide(data, callback) {
			if (window.spinner) window.spinner.hide();
			if (callback) callback();
		}
	}

};
"use strict";
/**
 * Created by Daniel on 3/30/2015.
 */

var geoAPI = {
    convertPosition: function convertPosition(position) {
        var p = {
            coords: {
                latitude: position.coords.latitude,
                longitude: position.coords.longitude,
                altitude: position.coords.altitude,
                accuracy: position.coords.accuracy,
                altitudeAccuracy: position.coords.altitudeAccuracy,
                heading: position.coords.heading,
                speed: position.coords.speed

            },
            timestamp: position.timestamp,
            isBackground: position.isBackground ? position.isBackground : false
        };
        return p;
    },
    convertBackGroundPosition: function convertBackGroundPosition(position) {
        var p = {
            coords: {
                latitude: position.latitude,
                longitude: position.longitude,
                altitude: position.altitude,
                accuracy: position.accuracy,
                speed: position.speed

            },
            timestamp: position.time,
            isBackground: true
        };
        return p;
    },
    getCurrentPosition: function getCurrentPosition(options, callback) {

        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(function (position) {
                callback(null, geoAPI.convertPosition(position));
            }, callback, options);
        } else {
            console.error("navigator.geolocation is undefined");
        }

        return this;
    },
    isAndroid: false,
    watchPosition: function watchPosition(options, callback) {
        function gotPosition(p) {
            p = geoAPI.convertPosition(p);
            p.watchId = watchId;

            var debugInfo = 'location: ' + p.coords.latitude + ',' + p.coords.longitude + ' ,isBackground: ' + p.isBackground + ' ' + new Date();
            console.log(debugInfo);

            var packet = new Packet(null, 'geo.onPositionChange', p);
            postMaster.broadcast(packet);
        }

        function onError(error) {
            console.log('Geo watchPosition: ', error.message);
            error.watchId = watchId;
            callback(error);
        }

        var watchId;

        if (navigator.geolocation && navigator.geolocation.watchPosition) {
            watchId = navigator.geolocation.watchPosition(gotPosition, onError, options);

            var bgSuccess = function bgSuccess(location) {
                gotPosition(geoAPI.convertBackGroundPosition(location));

                //backgroundGeolocation.finish();
            };

            var bgFailure = function bgFailure(error) {
                console.error('Background geo error');
            };

            var onDeviceReadyBGLocation = function onDeviceReadyBGLocation() {
                var isAndroid = navigator.platform.indexOf("Android") != -1 || navigator.platform.indexOf("Linux") != -1 || navigator.platform == null;

                //Only run custom background logic for Android
                if (!isAndroid) {
                    return;
                }

                //Do not run background Geolocation code if it's not defined
                if (typeof backgroundGeolocation === 'undefined') {
                    return;
                }

                if (typeof cordova !== 'undefined' && cordova.plugins && cordova.plugins.backgroundMode) {
                    cordova.plugins.backgroundMode.on('activate', function () {
                        cordova.plugins.backgroundMode.disableWebViewOptimizations();
                    });
                }

                backgroundGeolocation.configure(bgSuccess, bgFailure, {
                    desiredAccuracy: 0,
                    stationaryRadius: 1,
                    distanceFilter: 1,
                    interval: 1000,
                    locationProvider: backgroundGeolocation.provider.ANDROID_ACTIVITY_PROVIDER
                    //ANDROID_DISTANCE_FILTER_PROVIDER
                });

                backgroundGeolocation.start();
            };

            document.addEventListener('deviceready', onDeviceReadyBGLocation, false);
        } else {
            console.log('HTML5 position');
            watchId = setInterval(function () {
                geoAPI.getCurrentPosition(options, function (e, p) {
                    if (e) onError(e);else gotPosition(p);
                });
            }, options && options.timeout ? options.timeout : 5000);
        }
        callback();
    },
    clearWatch: function clearWatch(watchId, callback) {
        if (navigator.geolocation && navigator.geolocation.watchPosition) navigator.geolocation.clearWatch(watchId);else clearInterval(watchId);

        if (callback) callback();
    }
};
'use strict';

var inputAPI = {

  /**
   * Know if the api has been initialized already or not
   * @type {Boolean}
   */
  initialized: false,

  currentStepData: {},

  /**
   * Initialize the api by creating the dialog we are going to be using
   * @return {[type]} [description]
   */
  init: function init() {
    var _this = this;

    this.inputDialog = document.createElement('div');
    this.inputDialog.style.height = window.innerHeight + 'px';
    this.inputDialog.id = 'inputDialog';
    this.inputDialog.className = 'primaryBackgroundTheme';
    this.inputDialog.className = 'backgroundColorTheme';

    this.dialogNav = document.createElement('div');
    this.dialogNav.className = 'inputapi-nav titleBarBackgroundTheme';
    this.inputDialog.appendChild(this.dialogNav);

    this.dialogNavFlex = document.createElement('div');
    this.dialogNavFlex.className = 'inputapi-nav-flex';
    this.dialogNav.appendChild(this.dialogNavFlex);

    this.textarea = document.createElement('textarea');
    this.textarea.className = 'inputapi-textarea';
    this.textarea.onkeyup = function (e) {
      _this.currentStepData.textValue = e.target.value;
    };
    this.textarea.onfocus = function (e) {
      document.body.scrollTop = 0;
    };
    this.inputDialog.appendChild(this.textarea);

    this.cancelButton = document.createElement('span');
    this.cancelButton.className = 'inputapi-cancel titleBarTextAndIcons';
    this.dialogNavFlex.appendChild(this.cancelButton);

    this.title = document.createElement('h1');
    this.title.className = 'inputapi-nav-title titleBarTextAndIcons';
    this.dialogNavFlex.appendChild(this.title);

    this.doneButton = document.createElement('span');
    this.doneButton.className = 'inputapi-done titleBarTextAndIcons';
    this.dialogNavFlex.appendChild(this.doneButton);

    this.actionFooter = document.createElement('div');
    this.actionFooter.className = 'inputapi-footer';
    this.inputDialog.appendChild(this.actionFooter);

    if (window.location.pathname.indexOf('pluginTester') >= 0) {
      document.getElementById('app').appendChild(this.inputDialog);
    } else {
      document.body.appendChild(this.inputDialog);
    }

    this.initialized = true;
  },

  renderStep: function renderStep(stepOptions, handleCancel, handleNext) {
    var _this2 = this;

    if (window.Keyboard && window.Keyboard.shrinkView) {
      window.Keyboard.shrinkView(true);
      window.Keyboard.disableScrollingInShrinkView(true);
    }

    this.currentStepData = {};

    this.title.innerHTML = stepOptions.title || '';

    this.textarea.innerHTML = stepOptions.defaultValue || '';
    this.textarea.placeholder = stepOptions.placeholder || '';
    this.cancelButton.innerHTML = stepOptions.cancelText || 'Cancel';
    this.doneButton.innerHTML = stepOptions.saveText || 'Done';

    this.doneButton.onclick = function (e) {
      return handleNext(_this2.currentStepData);
    };
    this.cancelButton.onclick = function (e) {
      return handleCancel();
    };
  },

  /**
   * Show the input box
   * @param  {[Object]}   options  Array of settings for each input step
   * @param  {Function} callback Results callback
   */
  showTextDialog: function showTextDialog(options, callback) {
    var _this3 = this;

    if (!options || !callback) return;

    if (!this.initialized) this.init();
    // options should always be an array
    var steps = Array.isArray(options) ? options : [options];
    var results = [];

    function turnOffShrinkView() {
      if (window.Keyboard && window.Keyboard.shrinkView) {
        window.Keyboard.shrinkView(false);
        window.Keyboard.disableScrollingInShrinkView(false);
      }
    }

    var handleCancel = function handleCancel() {
      _this3.inputDialog.classList.remove('active');
      callback(null, { cancelled: true, results: results });
      setTimeout(turnOffShrinkView, 600);
    };

    var handleNext = function handleNext(currentStepResults) {
      results.push(currentStepResults);

      var nextStep = steps.shift();
      if (nextStep) {
        _this3.renderStep(nextStep, handleNext, handleCancel);
      } else {
        _this3.inputDialog.classList.remove('active');
        callback(null, { cancelled: false, results: results });
        setTimeout(turnOffShrinkView, 600);
      }
    };

    var currentStep = steps.shift();
    this.renderStep(currentStep, handleCancel, handleNext);
    setTimeout(function () {
      return _this3.inputDialog.classList.add('active');
    }, 0);
  }

};
'use strict';

$app.controller('authCtrl', ['$rootScope', '$scope', 'Upload', '$sce', function ($rootScope, $scope, Upload, $sce) {

    $scope._appRoot = window._appRoot;

    $scope.registerClick = false;

    var userLoginDomainSettingsAccess = undefined;
    if (window.appContext.currentApp && window.appContext.currentApp.config) {
        if (typeof window.appContext.currentApp.config.userLoginDomainSettings == 'undefined') {
            if (window.appContext.currentApp.config.type == "enterprise") {
                userLoginDomainSettingsAccess = 'enabled';
            }
        } else {
            userLoginDomainSettingsAccess = window.appContext.currentApp.config.userLoginDomainSettings;
        }
    }

    var domainSuffix;

    var passwordAtLeast8ComplexChars = 'Password must be at least 8 characters long, contains an upper case letter, a lower case letter, a number and a symbol.';
    $scope.loginTranslation = 'Log In';
    $scope.registerTranslation = 'Register';
    $scope.emailDoesNotExistTxt = "Email does not exist in system.";

    $scope.updateLoginTranslations = function (data) {
        console.log('emailDoesNotExist', data['emailDoesNotExist']);

        if (data['passwordAtLeast8ComplexChars']) passwordAtLeast8ComplexChars = data['passwordAtLeast8ComplexChars'];

        if (data['loginTranslation']) $scope.loginTranslation = data['loginTranslation'];

        if (data['registerTranslation']) $scope.registerTranslation = data['registerTranslation'];

        if (data['emailDoesNotExist']) $scope.emailDoesNotExistTxt = data['emailDoesNotExist'];
    };

    var showMenu = true;

    function shouldShowAppTerms() {
        if (appContext.currentApp && appContext.currentApp.config && appContext.currentApp.config.TermsOfUse) {
            return appContext.currentApp.config.TermsOfUse.indexOf('appdocumentation.com') < 0;
        } else {
            return false;
        }
    }

    //set authAPI the Ctrl
    window.authAPI.authCtrlScope = $scope;
    $rootScope.allowCancel = typeof $rootScope.allowCancel == 'undefined' ? true : $rootScope.allowCancel;
    $rootScope.authShown = false;

    $scope.secretCodeProvider = null;
    $scope.refWindow = null;
    $scope.errors = {};
    $scope.invalidCredentials = false;
    $scope.invalidReset = false;
    $scope.invalidRegister = false;
    $scope.msgError = null;
    $scope.msgSuccess = null;
    $scope.enableFacebook = true;
    $scope.enableTwitter = true;
    //$scope.email = '';
    $scope.password = '';
    $scope.userObj = { username: "",
        email: "" };

    $scope.loginCallback = null;
    var accessTokenAPI = "";
    var loginAPI = "";
    var resetPasswordAPI = "";
    var signOnStrategy = "";
    var clientId = "";
    var clientSecret = "";
    var contentType = "";
    var appId = window.appContext.currentApp.appId;
    var datastoreKey = window.appContext.currentApp.keys.datastoreKey;

    var context = {
        appId: appId,
        pluginId: 'authSettings',
        instanceId: 'authSettings',
        liveMode: window.appContext.liveMode,
        writeKey: datastoreKey
    };

    $scope.updateLoginCss = function () {
        updateLoginCss();
    };

    function updateLoginCss(customUISettings) {
        if (customUISettings) {
            customUISettings = window.loginUI.convertToCss(customUISettings) || '*{}';
            localStorage.loginUI = customUISettings;
        }

        var loginUI = customUISettings || localStorage.getItem('loginUI_' + appId);

        // Add custom css
        var styleTag = document.getElementById('custom-login-ui');

        // Create a new style tag if we don't  have it yet
        if (!styleTag) {
            var loginHolder = document.getElementsByClassName('login-holder')[0];
            styleTag = document.createElement('style');
            styleTag.id = 'custom-login-ui';
            loginHolder.appendChild(styleTag);
        }

        styleTag.innerHTML = loginUI;
    }

    updateLoginCss();

    var ds = new DatastoreAPI(context);

    function checkBoolDefaultTrue(value) {
        var result = typeof value === 'boolean' ? value : true;

        return result;
    }

    $scope.SSOLogin = false;
    ds.get({ tag: 'authSettings' }, handleAuthSettings);
    function handleAuthSettings(err, result) {
        if (err) {
            console.error(err);
        } else {
            if (result && result.data) {
                if (result.data.signOnStrategy == "SSOLogin") {
                    $scope.SSOLogin = true;
                    contentType = result.data.contentType;
                    if (contentType == "application/x-www-form-urlencoded" || contentType == "multipart/form-data") {
                        //put the hop in front to work around CORS
                        accessTokenAPI = window.siteConfig.endPoints.hopHost + result.data.accessTokenAPI;
                        loginAPI = window.siteConfig.endPoints.hopHost + result.data.loginAPI;
                    } else {
                        //backwards compatible
                        accessTokenAPI = result.data.accessTokenAPI;
                        loginAPI = result.data.loginAPI;
                    }

                    //able to disable FB and twitter even if they don't have SSO enabled.
                    $scope.enableFacebook = result.data.enableFacebook;
                    $scope.enableTwitter = result.data.enableTwitter;

                    signOnStrategy = result.data.signOnStrategy;
                    resetPasswordAPI = result.data.resetPasswordAPI;
                    clientId = result.data.clientId;
                    clientSecret = result.data.clientSecret;

                    setInterval(checkToken, 1000 * 60 * 15); //check SSO 15 minutes - to make sure user token isn't expired or revoked.
                }
                //able to disable FB and twitter even if they don't have SSO enabled.
                $scope.enableFacebook = checkBoolDefaultTrue(result.data.enableFacebook);
                $scope.enableTwitter = checkBoolDefaultTrue(result.data.enableTwitter);
                signOnStrategy = result.data.signOnStrategy;

                if (userLoginDomainSettingsAccess == 'enabled') {
                    domainSuffix = result.data.domain;
                }
                $scope.emailInputType = domainSuffix ? 'text' : 'email';
            } else {
                $scope.enableFacebook = true;
                $scope.enableTwitter = true;
            }
        }
    }

    function checkToken() {
        var ssoUserObj = JSON.parse(window.localStorage.getItem("SSO_USER"));
        if (ssoUserObj) {
            var dateNow = new Date().getTime() / 1000;
            if (dateNow > ssoUserObj.ssoExpiresAt) {
                // is the token expired?
                $scope.invalidCredentials = true;

                $rootScope.allowCancel = false;
                $rootScope.showMenu = false;
                //authAPI.login({}, null);
                $scope.showLogin(function (err, result) {
                    authAPI._setCurrentUser(result);

                    authAPI.triggerOnLogin(result);

                    $rootScope.allowCancel = true;
                    $rootScope.showMenu = true;
                    $scope.hideLogin();
                    if (!$scope.$$phase) $scope.$apply();
                });
            }
            var testAPI = accessTokenAPI;
            if (contentType == "multipart/form-data" || contentType == "application/x-www-form-urlencoded") {
                var headerObj = {
                    headers: {
                        'Authorization': "Bearer " + ssoUserObj.ssoUserToken,
                        'Content-Type': 'application/json'
                    }
                };
            } else {
                var headerObj = { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } };
                testAPI = accessTokenAPI + "?access_token=" + ssoUserObj.ssoUserToken;
            }
            window.bfUtils.http.get(testAPI, headerObj) //go to the profile to see if the token is still good.
            .success(function (result) {
                console.log(result);
            }).error(function (data, status, headers, config) {
                $scope.invalidCredentials = true;

                $rootScope.allowCancel = false;
                $rootScope.showMenu = false;
                $scope.showLogin(function (err, result) {
                    authAPI._setCurrentUser(result);
                    authAPI.triggerOnLogin(result);
                    $rootScope.allowCancel = true;
                    $rootScope.showMenu = true;
                    $scope.hideLogin();
                    if (!$scope.$$phase) $scope.$apply();
                });
            });
        }
    }

    $scope.closeLogin = function () {
        if ($scope.loginCallback) $scope.loginCallback();
        if ($rootScope.allowCancel) $scope.hideLogin();else resetLogin();
    };

    $scope.reset = function () {
        $scope.errors = {};
        $scope.showProgressMessage = false;
        $scope.invalidCredentials = false;
        $scope.invalidReset = false;
        $scope.invalidRegister = false;
        $scope.allowToRegister = false;
        $scope.uploadFile = null;

        $scope.userObj.email = null;
        $scope.userObj.username = null;
        $scope.password = null;
        $scope.secretCode = null;
        $scope.newPassword = null;
        $scope.confirmPassword = null;
        $scope.msgError = null;
        $scope.msgSuccess = null;
        $scope.uploadFile = null;
        $scope.firstName = null;
        $scope.lastName = null;

        $scope.secretCodeProvider = null;
        $scope.refWindow = null;
    };

    var hideForms = function hideForms() {
        $scope.successShown = false;
        $scope.registrationShown = false;
        $scope.loginShown = false;
        $scope.forgetPasswordShown = false;
        $scope.resetPasswordShown = false;
    };
    hideForms();

    $scope.openTermsAndConditions = function () {
        window.open('https://support.appdocumentation.com/terms/', '_system');
        return false;
    };

    $scope.registerUser = function () {
        $scope.registerClick = true;

        if ($scope.frmAuthRegister.$invalid) {
            return;
        }

        //Add logic here
        var isPasswordValid = window.validator.validatePassword($scope.password);

        if (!isPasswordValid) {
            var options = {
                data: {
                    title: ' ',
                    body: passwordAtLeast8ComplexChars,
                    disableCancel: true
                }
            };

            window.openDialog(options, function () {});

            return;
        }

        $scope.register();
        $scope.registerClick = false;
    };

    $scope.hideLogin = function () {
        $scope.reset();

        hideForms();
        $rootScope.authShown = false;
        $scope.loginCallback = null;
    };

    $scope.showRegistration = function () {
        $scope.reset();

        hideForms();
        $scope.registrationShown = true;
        $rootScope.authShown = true;
    };

    $scope.showForgetPassword = function () {
        $scope.reset();

        hideForms();
        $scope.forgetPasswordShown = true;
        $rootScope.authShown = true;
    };

    $scope.showSuccess = function (msg) {
        hideForms();
        $scope.msgSuccess = msg;
        $scope.successShown = true;
    };

    $scope.showResetPassword = function (callback) {
        $scope.reset();

        hideForms();
        $scope.resetPasswordShown = true;
        $rootScope.authShown = true;
        $scope.loginCallback = callback;
    };

    function resetLogin() {
        $scope.reset();

        hideForms();
        $rootScope.allowCancel = !$scope.loginOptions || $scope.loginOptions.allowCancel !== false;
        $rootScope.showMenuOnAuth = !$scope.loginOptions || $scope.loginOptions.showMenu !== false;
        $scope.loginShown = true;
        $rootScope.authShown = true;
        if (!$scope.$$phase) $scope.$apply();
    }

    $scope.updateLogin = function (loginUISettings) {

        if (loginUISettings) {
            updateLoginCss(loginUISettings);
        }

        $scope.loginCallback = function (err, result) {
            if (result) {
                window.authAPI._setCurrentUser(result);
                window.authAPI.triggerOnLogin(result);
            } else {
                console.error('authCtrl loginCallback error', err);
            }

            $rootScope.allowCancel = true;
            $rootScope.showMenu = true;
            $scope.hideLogin();
            if (!$scope.$$phase) $scope.$apply();
        };
        resetLogin();
    };

    $scope.updateLoginAuth = function (options) {
        $scope.enableFacebook = checkBoolDefaultTrue(options.enableFacebook);
        $scope.enableTwitter = checkBoolDefaultTrue(options.enableTwitter);

        if (options.domain && userLoginDomainSettingsAccess == 'enabled') {
            domainSuffix = options.domain;
        }

        if (!$scope.$$phase) $scope.$apply();
    };

    $scope.showLogin = function (callback) {
        $scope.loginCallback = callback;
        resetLogin();
    };

    $scope.resetPassword = function () {
        $scope.invalidReset = false;
        $scope.msgError = null;

        if ($scope.newPassword != $scope.confirmPassword) {
            $scope.invalidReset = false;
            $scope.msgError = 'Make sure new password and confirm password are equal';
            return;
        }

        var resetData = {
            email: $scope.email, "secretCode": $scope.secretCode, password: $scope.newPassword
        };

        var data = {
            "id": 1, "method": "users/changePassword",
            "params": resetData
        };

        var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

        window.bfUtils.http.jsonp(url, { bypassInterceptorForStatus: 404 }).success(function (result) {
            if (result && result.result) {
                $scope.showSuccess('Password reset successfully');
                var options = {
                    data: {
                        title: ' ',
                        body: 'Password reset successfully',
                        disableCancel: true
                    }
                };

                window.openDialog(options, function () {});
            } else {
                if (result && result.error) {
                    var options = {
                        data: {
                            title: ' ',
                            body: result.error.message,
                            disableCancel: true
                        }
                    };

                    window.openDialog(options, function () {});
                    console.error(result.error);
                }
            }
        }).error(function (data, status, headers, config) {
            $scope.invalidCredentials = true;

            console.error(data);
            if (callback) callback(data, null);
        });
    };

    $scope.forgotPassword = function (obj) {
        if (signOnStrategy != "SSOLogin") {
            $scope.invalidCredentials = false;

            var resetData = {
                email: $scope.email, "sendSecretCode": true
            };
            if (obj) {
                resetData.email = obj.email;
            }

            var data = {
                "id": 1, "method": "users/forgotPassword",
                "params": resetData
            };

            var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

            window.bfUtils.http.jsonp(url, { bypassInterceptorForStatus: 404 }).success(function (result) {
                if (result && result.result) {
                    $scope.showResetPassword();
                } else {
                    var options = {
                        data: {
                            title: ' ',
                            body: $scope.emailDoesNotExistTxt,
                            disableCancel: true
                        }
                    };

                    window.openDialog(options, function () {});

                    if (result) console.warn(result);
                }
            }).error(function (data, status, headers, config) {
                $scope.invalidCredentials = true;

                console.error(data);
            });
        } else {
            //this is SSO forgot password

            var queryStringChar = resetPasswordAPI.indexOf('?') === -1 ? "?" : "&",
                myResetPasswordAPI = resetPasswordAPI + queryStringChar + "email=" + $scope.email;

            window.bfUtils.http.get(myResetPasswordAPI, {
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
            }).success(function () {
                $scope.showLogin(function (err, result) {
                    authAPI._setCurrentUser(result);

                    authAPI.triggerOnLogin(result);

                    $rootScope.allowCancel = true;
                    $rootScope.showMenu = true;
                    $scope.hideLogin();
                    if (!$scope.$$phase) $scope.$apply();
                });
            }).error(function (data, status, headers, config) {
                if (data) console.error(data);
            });
        }
    };

    function buildfireLogin(obj, callback) {

        if (!window.appContext || !window.appContext.currentApp) {
            console.error('invalid appContext');
            return;
        }

        $scope.invalidCredentials = false;

        if (!callback) callback = $scope.loginCallback;

        var pushSDK = null;
        if (typeof push == 'undefined') pushSDK = {};else pushSDK = push;

        var email = $scope.userObj.email;

        if (userLoginDomainSettingsAccess == 'enabled' && domainSuffix && !email.includes("@")) {
            email = email + domainSuffix;
        }

        console.warn('email', email);

        var loginData = {
            email: email,
            password: $scope.password,
            deviceId: pushSDK.deviceId,
            osType: pushSDK.platform ? pushSDK.platform.toLowerCase() : 'web',
            externalAppId: window.appContext.currentApp.appId
        };
        if (obj) {
            loginData.email = obj.email;
            loginData.password = obj.password;
        }

        var data = {
            "id": 1, "method": "users/login",
            "params": loginData
        };

        var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

        window.bfUtils.http.jsonp(url, { bypassInterceptorForStatus: 404 }).success(function (result) {
            if (result && result.result && result.result.userToken) {

                authAPI._setCurrentUser(result.result);
                $rootScope.$broadcast('loginSuccessfully', result.result);
                if (callback) callback(null, result.result);
            } else {
                $scope.invalidCredentials = true;

                var error = null;
                if (result && result.error) {
                    console.warn('login error: ', result.error);
                    error = result.error;
                }
                if (error && error.message) $scope.msgError = error.message;else $scope.msgError = 'Invalid Email or Password';
                if (callback) callback(error, null);
            }
        }).error(function (data, status, headers, config) {
            $scope.invalidCredentials = true;

            console.error(data);
            if (callback) callback(data, null);
        });
    }

    function SSOLogin(obj, callback) {
        var options = { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } };
        var email = $scope.userObj.username;

        if (userLoginDomainSettingsAccess == 'enabled' && domainSuffix && !email.includes("@")) {
            email = email + domainSuffix;
        }

        if (contentType == "application/x-www-form-urlencoded") {
            var loginObj = encodeURIComponent("grant_type") + "=" + encodeURIComponent("password") + "&" + encodeURIComponent("username") + "=" + encodeURIComponent(email) + "&" + encodeURIComponent("password") + "=" + encodeURIComponent($scope.password) + "&" + encodeURIComponent("client_id") + "=" + encodeURIComponent(clientId) + "&" + encodeURIComponent("client_secret") + "=" + encodeURIComponent(clientSecret);
        } else if (contentType == "multipart/form-data") {
            options = { transformRequest: angular.identity, headers: { 'Content-Type': undefined } };
            var loginObj = new FormData();
            loginObj.append('username', email);
            loginObj.append('password', $scope.password);
        } else {
            var loginObj = {
                grant_type: "password",
                username: email,
                password: $scope.password,
                client_id: clientId
            };
        }
        window.bfUtils.http.post(loginAPI, loginObj, options).success(function (result) {
            var ssoUserObj = JSON.parse(window.localStorage.getItem("SSO_USER"));
            if (!ssoUserObj) var ssoUserObj = {};
            if (typeof result == "string") {
                try {
                    result = JSON.parse(result);
                } catch (e) {
                    console.warn('Unexpected parsing issue', e);
                }
            }
            if (result && result.access_token) {
                ssoUserObj.ssoUserToken = result.access_token; //save SSO token
            } else {
                ssoUserObj.ssoUserToken = result.replace(/["]+/g, '');
            }
            if (result && result.expires_in && result.issued_at) {
                ssoUserObj.ssoExpiresAt = result.issued_at + result.expires_in;
            } else {
                ssoUserObj.ssoExpiresAt = 1902608081000; //if they do not send expiration info, set 10 years in future.
            }

            window.localStorage.setItem("SSO_USER", JSON.stringify(ssoUserObj));

            var pushSDK = null;
            if (typeof push == 'undefined') pushSDK = {};else pushSDK = push;

            //strip out the hop if it is there
            var passedAccessTokenAPI = accessTokenAPI.replace(window.siteConfig.endPoints.hopHost, "");;

            var loginData = {
                accessToken: ssoUserObj.ssoUserToken,
                accessTokenAPI: passedAccessTokenAPI,
                deviceId: pushSDK.deviceId,
                osType: pushSDK.platform ? pushSDK.platform.toLowerCase() : 'web',
                externalAppId: window.appContext.currentApp.appId,
                loginProviderType: 'SSO',
                email: $scope.userObj.username,
                contentType: contentType
            };
            var data = {
                "id": 1, "method": "users/loginSSO",
                "params": loginData
            };

            var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

            window.bfUtils.http.jsonp(url, { bypassInterceptorForStatus: 404 }).success(function (result) {
                if (result && result.result) {
                    authAPI._setCurrentUser(JSON.stringify(result.result));
                    $rootScope.$broadcast('loginSuccessfully', result.result);
                    callback(null, result.result);
                } else {
                    $scope.invalidRegister = true;

                    var error = null;
                    if (result && result.error) {
                        $scope.msgError = result.error.message;
                        $scope.invalidCredentials = true;
                        console.error(result.error);
                    } else {
                        if (result = "Could not retrieve profile info.") {
                            $scope.msgError = result;
                            $scope.invalidCredentials = true;
                            console.error(result);
                        }
                    }
                }
            }).error(function (data, status, headers, config) {
                console.error(data);
                if (callback) callback(data, null);
            });
        }).error(function (data, status, headers, config) {
            $scope.invalidCredentials = true;

            if (data && data.error_description) {
                console.error(data);
                $scope.msgError = data.error_description;
            } else $scope.msgError = "Login Failed";

            if (callback) callback("Login Failed", null);
        });
    }

    $scope.showBackLogin = function () {
        authAPI.login();
    };

    $scope.login = function (obj, callback) {
        if (window.spinner && window.spinner.show) {
            window.spinner.show(true);
        }

        if (signOnStrategy != "SSOLogin") {
            buildfireLogin(obj, function (err, result) {
                if (err) {

                    var options = {
                        data: {
                            title: ' ',
                            body: 'Invalid Login',
                            disableCancel: true
                        }
                    };

                    window.openDialog(options, function () {});

                    console.error(err);
                    if (callback) callback(err, null);
                } else {
                    if (!callback) callback = $scope.loginCallback;

                    if (callback) callback(null, result);
                }
                if (window.spinner && window.spinner.hide) {
                    window.spinner.hide(true);
                }
            });
        } else {
            SSOLogin(obj, function (err, result) {
                if (err) {
                    console.error(err);

                    var options = {
                        data: {
                            title: ' ',
                            body: 'Invalid Login',
                            disableCancel: true
                        }
                    };

                    window.openDialog(options, function () {});

                    if (callback) callback(err, null);
                } else {
                    if (!callback) callback = $scope.loginCallback;
                    callback(null, result);
                }
                if (window.spinner && window.spinner.hide) {
                    window.spinner.hide(true);
                }
            });
        }
    };

    var update = function update(userData, callback) {
        var data = {
            "id": 1, "method": "users/update",
            "params": userData
        };

        var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

        window.bfUtils.http.jsonp(url, { bypassInterceptorForStatus: 404 }).success(function (result) {
            if (result.error) {
                var error = null;
                if (result && result.error) {
                    console.error(result.error);
                    error = result.error;
                }
                if (callback) callback(error, null);
            } else {
                var currentUser = authAPI.getCurrentUser();
                if (currentUser != null) {
                    currentUser.firstName = userData.firstName;
                    currentUser.lastName = userData.lastName;
                    currentUser.displayName = userData.displayName;
                    currentUser.imageUrl = userData.imageUrl;
                    authAPI._setCurrentUser(currentUser);
                }
                if (callback) callback(null, currentUser);
            }
        }).error(function (data, status, headers, config) {
            console.error(data);
            if (callback) callback(data, null);
        });
    };

    $scope.loadGDPR = function (key) {
        var email = $scope.userObj.email;

        var url = siteConfig.endPoints.crmHost + "/documents/" + key + "/check?userKey=" + email + "&withDetails=true";

        bfUtils.http.get(url).success(function (result) {
            if (result) {
                if (!result[key].isAccepted) {
                    $scope.GDPR_title = $sce.trustAsHtml(result[key].title);
                    $scope.GDPR_subtitle = $sce.trustAsHtml(result[key].subtitle);
                    $scope.GDPR_details = $sce.trustAsHtml(result[key].details);
                    $scope.showGDPR = true;

                    $rootScope.$broadcast('hideNav');

                    if (!$scope.$$phase) $scope.$apply();
                }
            }
        }).error(function (err) {
            console.error(err);
        });
    };

    $scope.hideGDPR = function () {
        $rootScope.$broadcast('displayNav');

        $scope.showGDPR = false;
        $scope.GDPR_title = null;
        $scope.GDPR_subtitle = null;
        $scope.GDPR_details = null;
    };

    $scope.showTermsOfService = function () {
        $scope.loadGDPR('bf_terms_and_conditions');
    };

    $scope.showPrivacyPolicy = function () {
        $scope.loadGDPR('bf_privacy_policy');
    };

    $scope.showAppTerms = function () {
        window.open(appContext.currentApp.config.TermsOfUse, '_system');
    };

    $scope.shouldShowAppTerms = shouldShowAppTerms();

    $scope.saveGDPR = function () {
        var termsConditionsKey = "bf_terms_and_conditions";
        var privacyPolicyKey = "bf_privacy_policy";

        var getInfo = function getInfo(callback) {
            window.$http.get("https://ipapi.co/json/").success(function (data) {
                if (data) {
                    var formattedData = {
                        ipInfo: {
                            city: data.city,
                            country: data.country_name,
                            countryCode: data.country,
                            lat: data.latitude,
                            lon: data.longitude,
                            regionName: data.region,
                            timezone: data.timezone,
                            zip: data.postal,
                            ip: data.ip
                        }
                    };
                    callback(null, formattedData);
                } else {
                    callback(null, null);
                }
            }).error(function (response) {
                callback(null, null);
            });
        };

        getInfo(function (err, data) {
            var info = {};
            if (data) info = data;
            info.appId = appContext.currentApp.appId;

            var termsConditionsKeyUrl = siteConfig.endPoints.crmHost + "/documents/" + termsConditionsKey + "/accept";
            var privacyPolicyKeyUrl = siteConfig.endPoints.crmHost + "/documents/" + privacyPolicyKey + "/accept";
            bfUtils.http.post(termsConditionsKeyUrl, {
                userKey: $scope.userObj.email,
                info: info,
                source: "app"
            }).success(function (result) {
                bfUtils.http.post(privacyPolicyKeyUrl, {
                    userKey: $scope.userObj.email,
                    info: info,
                    source: "app"
                }).success(function (result) {
                    window.location.hash = 'htmlBody';
                }).error(function (err) {
                    console.error(err);
                });
            }).error(function (err) {
                console.error(err);
            });
        });
    };

    $scope.register = function (obj, callback) {

        if (!window.appContext || !window.appContext.currentApp) {
            console.error('invalid appContext');
            return;
        }

        $scope.invalidRegister = false;

        if (!callback) callback = $scope.loginCallback;

        var pushSDK = null;
        if (typeof push == 'undefined') pushSDK = {};else pushSDK = push;

        var regData = {
            firstName: $scope.firstName || $scope.userObj.email,
            lastName: $scope.lastName || '',
            email: $scope.userObj.email,
            password: $scope.password,
            deviceId: pushSDK.deviceId,
            osType: pushSDK.platform ? pushSDK.platform.toLowerCase() : 'web',
            externalAppId: window.appContext.currentApp.appId
        };
        if (obj) {
            regData.email = obj.email;
            regData.password = obj.password;
            regData.firstName = obj.firstName;
            regData.lastName = obj.lastName;
            if (obj.loginProviderType) regData.loginProviderType = obj.loginProviderType;
        }

        var data = {
            "id": 1, "method": "users/register",
            "params": regData
        };

        var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

        window.bfUtils.http.jsonp(url, { bypassInterceptorForStatus: 404 }).success(function (result) {
            if (result && result.result) {

                $scope.saveGDPR(function (err) {
                    if (err) return console.error(err);
                });

                $scope.login({ email: regData.email, password: regData.password }, function (err, result) {
                    if (result && result.userToken) {
                        $scope.upload($scope.uploadFile, function (err, result) {
                            if (err) {
                                if (callback) callback(err, null);
                            } else {
                                var currentUser = authAPI.getCurrentUser();
                                if (result) {
                                    var userData = {
                                        userToken: currentUser.userToken,
                                        firstName: regData.firstName,
                                        lastName: regData.lastName,
                                        displayName: regData.firstName + ' ' + regData.lastName,
                                        imageUrl: result.result
                                    };

                                    update(userData, callback);
                                } else {
                                    if (callback) callback(null, currentUser);
                                }
                            }
                        });
                        authAPI.trackRegister(result);
                    }
                });
            } else {
                $scope.invalidRegister = true;

                var error = null;
                if (result && result.error) {

                    var options = {
                        data: {
                            title: ' ',
                            body: result.error.message,
                            disableCancel: true
                        }
                    };

                    window.openDialog(options, function () {});
                    console.warn(result.error);
                    error = result.error;
                }
            }
        }).error(function (data, status, headers, config) {
            console.error(data);
        });
    };

    $scope.upload = function (files, callback) {
        var currentUser = authAPI.getCurrentUser();
        if (currentUser != null) {
            var url = window.siteConfig.endPoints.authHost + "/src/server.js?method=users/uploadImage";
            if (files && files.length == 1) {
                var file = files[0];
                Upload.upload({
                    url: url,
                    fields: { 'userToken': currentUser.userToken },
                    file: file
                }).progress(function (evt) {
                    $scope.progressMessage = true;
                    var progressPercentage = parseInt(100.0 * evt.loaded / evt.total);
                    console.log('progress: ' + progressPercentage + '% ' + evt.config.file.name);
                }).success(function (data, status, headers, config) {
                    console.log('file ' + config.file.name + 'uploaded.');

                    if (callback) callback(null, data);
                }).error(function (err) {
                    $scope.msgError = '';
                    $scope.invalidRegister = true;

                    if (callback) callback(err, null);
                });
            } else {
                if (callback) callback(null, null);
            }
        } else {
            if (callback) callback({ message: "Invalid user" }, null);
        }
    };

    $scope.requestLoginProvider = function (loginProviderType) {
        var data = {
            "id": 1, "method": "secretCode/request",
            "params": {}
        };
        var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

        if (!$scope.refWindow || $scope.refWindow.closed) {
            window.bfUtils.http.jsonp(url, { bypassInterceptorForStatus: 404 }).success(function (result) {
                if (result != null && result.result != null && result.result.code) {
                    $scope.secretCodeProvider = result.result.code;

                    $scope.refWindow = window.open(window.siteConfig.endPoints.authHost + '/website/index.html?v=2.0&code=' + encodeURIComponent($scope.secretCodeProvider) + '&loginProviderType=' + loginProviderType, '_blank', 'location=no,enableViewportScale=yes');
                    if ($scope.refWindow && $scope.refWindow.addEventListener) {
                        $scope.refWindow.addEventListener('exit', function () {
                            $scope.refWindow = null;
                        });
                    }

                    var attempts = 120;
                    setTimeout(secretCodeLogin, 1000, attempts);
                }
            }, function (e) {
                console.log(JSON.stringify(e));
                //callback({ error: { code: -1, message: "failed to communicate with the server" } });
            });
        }
    };

    var secretCodeLogin = function secretCodeLogin(attempts) {

        if (!window.appContext || !window.appContext.currentApp) {
            console.error('invalid appContext');
            return;
        }

        if (attempts > 0) {
            var data = {
                "id": 1, "method": "users/secretCodeLogin",
                "params": {
                    code: $scope.secretCodeProvider,
                    deviceId: push.deviceId,
                    osType: push.platform ? push.platform.toLowerCase() : 'web',
                    externalAppId: window.appContext.currentApp.appId
                }
            };

            var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

            window.bfUtils.http.jsonp(url, { bypassInterceptorForStatus: 404 }).success(function (result) {
                if (result.error) {
                    var failedLogin = false;
                    if (result.error.code == 1300) {
                        failedLogin = true;
                    }
                    if (result.error.code == 1303) {
                        failedLogin = true;
                    }
                    if (failedLogin) {
                        $scope.secretCodeProvider = null;
                        if ($scope.refWindow != null) {
                            $scope.refWindow.close();
                            $scope.refWindow = null;
                        }
                    }
                } else {
                    if (result.result != null && result.result.userToken != null) {
                        authAPI._setCurrentUser(result.result);

                        if ($scope.refWindow != null) {
                            $scope.refWindow.close();
                            $scope.refWindow = null;
                        }
                        if ($scope.loginCallback) $scope.loginCallback(null, authAPI.getCurrentUser());
                    } else {
                        //to handle if some one closed the popup window
                        if ($scope.refWindow != null && $scope.refWindow.closed) {
                            $scope.refWindow.close();
                            $scope.secretCodeProvider = null;
                            $scope.refWindow = null;
                        } else {
                            setTimeout(secretCodeLogin, 1000, attempts - 1);
                        }
                    }
                }
            }, function (e) {
                console.log(JSON.stringify(e));
                //callback({ error: { code: -1, message: "faild to communicate with the server" } });
            });
        } else {
            $scope.secretCodeProvider = null;
            if ($scope.refWindow != null) {
                $scope.refWindow.close();
                $scope.refWindow = null;
            }
            if ($scope.loginCallback) {
                $scope.invalidCredentials = true;
                $scope.msgError = 'Invalid Login';
                $scope.loginCallback(null, null);
            }
        }
    };
}]);
"use strict";
/**
 * Created by Ayman on 9/10/2015.
 */

var authAPI = {
	authCtrlScope: null,
	init: function init(context) {
		this.context = context;
		/*var currentUser = authAPI.getCurrentUser();
  if (currentUser)
  	authAPI.triggerOnLogin(currentUser);*/
	},
	login: function login(options, callback) {
		var currentUser = this.getCurrentUser();
		if (currentUser) {
			if (callback) callback(null, currentUser);
			authAPI.triggerOnLogin(currentUser);
		} else {
			authAPI.authCtrlScope.loginOptions = options;
			authAPI.authCtrlScope.showLogin(function (err, result) {
				if (!err && result) {
					authAPI._setCurrentUser(result);

					authAPI.triggerOnLogin(result);
					authAPI._checkGDPR(result);
					authAPI.authCtrlScope.hideLogin();
					if (!authAPI.authCtrlScope.$$phase) authAPI.authCtrlScope.$apply();
				}
				if (callback) callback(err, result);
			});
			if (!authAPI.authCtrlScope.$$phase) authAPI.authCtrlScope.$apply();
		}
	},
	_setCurrentUser: function _setCurrentUser(user) {
		localStorage.setItem('AUTH_CURRENT_USER', JSON.stringify(user));
	},
	///don't delete this is used for areas that needs to override this function
	secondaryUserLookup: function secondaryUserLookup() {
		return null;
	},
	getCurrentUser: function getCurrentUser(data, callback) {
		if (typeof data == 'function') {
			callback = data;
		}
		var user = authAPI.secondaryUserLookup();
		if (!user) {
			user = localStorage.getItem('AUTH_CURRENT_USER');
			user = JSON.parse(user);
		}
		if (!(user && user.userToken)) {
			user = null;
		}
		if (callback) callback(null, user);else return user;
	},
	_checkGDPR: function _checkGDPR(user) {
		if (!user) return;
		var termsConditionsKey = "bf_terms_and_conditions";
		var privacyPolicyKey = "bf_privacy_policy";
		var url = siteConfig.endPoints.crmHost + "/documents/" + termsConditionsKey + "," + privacyPolicyKey + "/check?userKey=" + user.username;
		if ((bfUtils.isAppHtml5Version || bfUtils.isMobileDevice || bfUtils.isPwaAndroid || bfUtils.isPwaiOS) && window.appContext && window.appContext.liveMode == 1) {
			bfUtils.http.get(url).success(function (result) {
				if (result) {
					if (!result[termsConditionsKey].isAccepted || !result[privacyPolicyKey].isAccepted) window.location.hash = 'gdpr';
				}
			}).error(function (err) {
				console.error(err);
			});
		}
	},
	logout: function logout() {
		this._setCurrentUser(null);
		authAPI.triggerOnLogout(null);
	},
	trackRegister: function trackRegister(user) {
		//track register only on live mode
		if (window.appContext && window.appContext.liveMode) {
			var analyticsAPI = new AnalyticsAPI(authAPI.context);
			analyticsAPI.setUserProperties({ email: user.email, username: user.username, firstName: user.firstName, lastName: user.lastName });
			analyticsAPI.trackAction('app/userRegistered');

			var historyUsersItem = localStorage.getItem('HISTORY_USERS');
			if (historyUsersItem) {
				var historyUsers = JSON.parse(historyUsersItem);
				if (historyUsers.length && historyUsers.indexOf(user._id) == -1) {
					historyUsers.push(user._id);
					localStorage.setItem('HISTORY_USERS', JSON.stringify(historyUsers));
				}
			} else {
				localStorage.setItem('HISTORY_USERS', JSON.stringify([user._id]));
			}
		}
	},
	onLogin: function onLogin(callback) {
		document.addEventListener('AUTH_CURRENT_USER_ON_LOGIN', callback, false);
	},
	onLogout: function onLogout(callback) {
		document.addEventListener('AUTH_CURRENT_USER_ON_LOGOUT', callback, false);
	},
	onUpdate: function onUpdate(callback) {
		document.addEventListener('AUTH_CURRENT_USER_ON_UPDATE', callback, false);
	},
	triggerOnUpdate: function triggerOnUpdate(user) {
		if (!user) user = authAPI.getCurrentUser();
		var onUpdateEvent = new CustomEvent('AUTH_CURRENT_USER_ON_UPDATE', { 'detail': user });
		document.dispatchEvent(onUpdateEvent);
	},
	triggerOnLogin: function triggerOnLogin(user) {
		var onUpdateEvent = new CustomEvent('AUTH_CURRENT_USER_ON_LOGIN', { 'detail': user });
		document.dispatchEvent(onUpdateEvent);
	},
	triggerOnLogout: function triggerOnLogout() {
		var onUpdateEvent = new CustomEvent('AUTH_CURRENT_USER_ON_LOGOUT', { 'detail': null });
		document.dispatchEvent(onUpdateEvent);
	},
	openProfile: function openProfile(userId) {
		window.location.hash = "userProfile/" + userId;
	},
	getUserProfile: function getUserProfile(options, callback) {
		if (!options || !options.userId) {
			throw new Error("userId have not been provided to getUserInfo");
			return;
		}

		var userInfo = null;

		var getUserSocial = function getUserSocial() {
			var data = {
				"id": 1, "method": "users/getUserProfile",
				"params": { userId: options.userId }
			};

			var url = window.siteConfig.endPoints.socialHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

			bfUtils.http.jsonp(url, { bypassInterceptorForStatus: 404 }).success(function (result) {
				if (callback) {
					if (result && result.result) {
						userInfo = angular.extend({}, result.result, userInfo);
						if (userInfo) {
							callback(null, userInfo);
						} else callback(null, null);
					} else callback(null, userInfo);
				}
			}).error(function (data, status, headers, config) {
				if (callback) callback(data, null);
			});
		};

		var data = {
			"id": 1, "method": "users/getPublicUser",
			"params": { userId: options.userId }
		};

		var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

		bfUtils.http.jsonp(url, { bypassInterceptorForStatus: 404 }).success(function (result) {
			if (callback) {
				if (result && result.result) {
					userInfo = result.result;
					getUserSocial();
				} else callback(null, null);
			}
		}).error(function (data, status, headers, config) {
			console.error(data);
			if (callback) callback(data, null);
		});
	},
	getUsersByEmail: function getUsersByEmail(options, callback) {
		if (!options || !options.emails) {
			throw new Error("No emails have not been provided to getUserByEmail");
			return;
		}

		var mergeResults = function mergeResults(users, profiles) {
			for (var i = 0; i < users.length; i++) {
				for (var j = 0; j < profiles.length; j++) {
					if (users[i].email == profiles[j].email) {
						users[i].phone = profiles[j].phone;
					}
				}
			}

			callback(null, users);
		};

		var getProfiles = function getProfiles(users) {
			var data = {
				"id": 1, "method": "users/getUsersProfilesByEmail",
				"params": { emails: options.emails }
			};

			var url = window.siteConfig.endPoints.socialHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

			bfUtils.http.jsonp(url, { bypassInterceptorForStatus: 404 }).success(function (result) {
				if (callback) {
					if (result && result.result) {
						mergeResults(users, result.result);
					} else callback(null, users);
				}
			}).error(function (data, status, headers, config) {
				console.error(data);
				if (callback) callback(data, null);
			});
		};

		var data = {
			"id": 1, "method": "users/getUsersByEmail",
			"params": { emails: options.emails }
		};

		var url = window.siteConfig.endPoints.authHost + "/src/server.js?callback=JSON_CALLBACK&data=" + encodeURIComponent(JSON.stringify(data));

		bfUtils.http.jsonp(url, { bypassInterceptorForStatus: 404 }).success(function (result) {
			if (callback) {
				if (result && result.result) {
					getProfiles(result.result);
				} else callback(null, null);
			}
		}).error(function (data, status, headers, config) {
			console.error(data);
			if (callback) callback(data, null);
		});
	},
	getUserPictureUrl: function getUserPictureUrl(params) {
		var key = null;
		var value = null;
		if (!params) {
			params = {};
		}
		if (params.userId) {
			key = 'userId';
			value = params.userId;
		}
		if (params.email) {
			key = 'email';
			value = params.email;
		}
		if (params.username) {
			key = 'username';
			value = params.username;
		}
		if (!key || !value) throw Error('Invalid user picture params');
		return window.siteConfig.endPoints.authHost + "/src/server.js/user/picture?" + key + "=" + value;
	}
};
'use strict';

$app.controller('modalCtrl', ['$scope', '$dialog', '$data', function ($scope, $dialog, $data) {
    $scope.modal = {};

    $scope.modal.body = $data.body;

    $scope.modal.title = $data.title ? $data.title : 'Confirm';
    $scope.modal.okText = $data.okText ? $data.okText : "OK";
    $scope.modal.cancelText = $data.cancelText ? $data.cancelText : "Cancel";
    $scope.modal.disableCancel = $data.disableCancel ? $data.disableCancel : false;

    $scope.close = function () {
        $dialog.close(false);
    };

    $scope.confirm = function () {
        $dialog.close(true);
    };
}]);
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

setTimeout(function () {
    if (sessionStorage.getItem('notification')) {
        try {
            var notification = JSON.parse(sessionStorage.getItem('notification'));
            LocalNotificationsAPI.navToPlugin(notification);
        } finally {
            sessionStorage.removeItem('notification');
        }
    }
}, 2000);

var LocalNotificationsAPI = function () {
    var webNotificationsQueue = {};
    var pluginMissingError = "Cordova notification plugin not installed";

    function _LocalNotificationsAPI(context) {
        this.context = context;
    }

    _LocalNotificationsAPI.prototype = {
        schedule: function schedule(notification, callback) {
            var id = generateId();
            var now = new Date();

            if (_LocalNotificationsAPI.isPluginAvailable()) {
                //Don't allow users to specify badge options
                notification.badge = 0;

                //If the send time isn't specified, send it real soon
                if (!notification.at) {
                    notification.at = new Date(now.getTime() + 250);
                } else {
                    notification.at = Date.parse(notification.at);
                }

                notification.id = id;

                notification.data = {
                    actionItem: notification.actionItem,
                    pluginData: notification.data,
                    returnInstanceId: notification.returnToPluginInstanceId || this.context.instanceId,
                    launchInstanceId: this.context.instanceId
                };

                cordova.plugins.notification.local.schedule(notification);

                callback(null, { id: notification.id });
            } else {
                var diff = Math.abs(Date.parse(notification.at) - Date.now());

                //Don't send old notifications, give or take a few seconds
                if (diff < -2000) {
                    return;
                }

                notification.data = {
                    actionItem: notification.actionItem,
                    pluginData: notification.data,
                    returnInstanceId: notification.returnToPluginInstanceId || this.context.instanceId,
                    launchInstanceId: this.context.instanceId
                };

                var timer = setTimeout(function () {
                    if (notificationInWebQueue(id)) {
                        _LocalNotificationsAPI.notificationModal(notification);
                        removeFromWebQueue(id);
                    }
                }, diff);

                webNotificationsQueue[id] = timer;
                callback(null, { id: id });
            }
        },
        cancel: function cancel(id, callback) {
            if (_LocalNotificationsAPI.isPluginAvailable()) {
                cordova.plugins.notification.local.cancel(id);
                callback(null, { id: id });
            } else if (!isDevice()) {
                removeFromWebQueue(id);
                callback(null, { id: id });
            } else {
                callback(new Error(pluginMissingError), null);
            }
        },

        checkPermission: function checkPermission(data, callback) {
            if (!isDevice()) {
                //Special permissions aren't required in web, so we return true
                if (callback) callback(null, true);
                return;
            }

            if (!_LocalNotificationsAPI.isPluginAvailable()) {
                if (callback) callback(new Error(pluginMissingError), false);

                console.warn(pluginMissingError);
                return;
            }

            cordova.plugins.notification.local.hasPermission(function (granted) {
                if (callback) callback(null, granted);
            });
        },

        requestPermission: function requestPermission(data, callback) {
            if (!isDevice()) {
                //Special permissions aren't required in web, so we return true
                if (callback) callback(null, true);
                return;
            }

            /// ask only if permission hasn't been granted
            if (!_LocalNotificationsAPI.isPluginAvailable()) {
                if (callback) callback(new Error(pluginMissingError), false);

                console.warn(pluginMissingError);
                return;
            }

            cordova.plugins.notification.local.hasPermission(function (granted) {
                if (granted) {
                    if (callback) callback(null, true);
                } else {
                    cordova.plugins.notification.local.registerPermission(function (registerGranted) {
                        if (registerGranted) {
                            if (callback) callback(null, true);
                        } else {
                            console.warn('Permission not granted for local notifications');
                            if (callback) callback(null, false);
                        }
                    });
                }
            });
        }
    };

    function generateId() {
        //Note: ID must be 9 digits or less
        return Math.floor(Math.random() * 1000000000);
    }

    function notificationInWebQueue(id) {
        return webNotificationsQueue.hasOwnProperty(id);
    }

    function removeFromWebQueue(id) {
        if (notificationInWebQueue(id)) {
            clearTimeout(webNotificationsQueue[id]);
            delete webNotificationsQueue[id];
        }
    }

    function isDevice() {
        return typeof cordova != "undefined";
    }

    _LocalNotificationsAPI.isPluginAvailable = function () {
        var isAvailable = true;

        if (typeof cordova == "undefined" || !cordova.plugins || !cordova.plugins.notification || !cordova.plugins.notification.local) {

            isAvailable = false;
        }

        return isAvailable;
    };

    _LocalNotificationsAPI.getPlatform = function () {
        return device.platform ? device.platform.toLowerCase() : '';
    };

    _LocalNotificationsAPI.notificationModal = function (notification) {
        var options = {
            data: { title: notification.title, body: notification.text }
        };

        window.openDialog(options, function (result) {

            if (result) {
                _LocalNotificationsAPI.navToPlugin(notification);
            }
        });
    };

    _LocalNotificationsAPI.navToPlugin = function (notification) {
        var _nav = function _nav() {
            var delay = 2000;
            var actions = {
                doNothing: 0,
                sendToLauncher: 1,
                sendToPlugin: 2
            },
                action = actions.sendToPlugin,
                returnInstanceId;

            if (_typeof(notification.data) !== 'object') notification.data = JSON.parse(notification.data);

            // if an action is available apply the action
            if (notification.data.actionItem) {
                //Perform action
                ActionItemsAPI.prototype.execute(notification.data.actionItem, function (err, wasSuccess) {});
            }

            returnInstanceId = notification.data.returnInstanceId ? notification.data.returnInstanceId.toLowerCase() : '';

            if (returnInstanceId == 'home' || returnInstanceId == 'none') action = actions.doNothing;else if (postMaster.launcherPluginAPI && postMaster.launcherPluginAPI.context && postMaster.launcherPluginAPI.context.instanceId == returnInstanceId) action = actions.sendToLauncher;

            if (action === actions.doNothing) {
                return;
            }

            if (actions === actions.sendToLauncher) {
                delay = 500;

                postMaster.launcherPluginAPI.navigation.navigateHome();
            } else {
                action = actions.sendToPlugin;

                if (postMaster.widgetPluginAPI && postMaster.widgetPluginAPI.context && postMaster.widgetPluginAPI.context.instanceId == notification.data.returnInstanceId) {
                    delay = 500;
                } else {
                    postMaster.launcherPluginAPI.navigation.navigateToPluginInstance({
                        instanceId: notification.data.returnInstanceId
                    });
                }
            }

            setTimeout(function () {
                var packet = new Packet(null, 'notifications.localNotification.onClick', notification.data.pluginData);

                if (action === actions.sendToLauncher) {
                    postMaster.launcherPluginAPI.sendMessage(null, packet);
                } else {
                    postMaster.widgetPluginAPI.sendMessage(null, packet);
                }
            }, delay);
        };

        var initialDelay = postMaster.launcherPluginAPI ? 0 : 1500;
        setTimeout(function () {
            if (postMaster.launcherPluginAPI) {
                _nav();
            }
        }, initialDelay);
    };

    return _LocalNotificationsAPI;
}();

document.addEventListener('deviceready', function () {
    if (LocalNotificationsAPI.isPluginAvailable()) {
        //iOS: Triggers when a notification fires and the app is in focus
        //Android: Triggers when a notification fires, regardless of the app being in focus or not
        cordova.plugins.notification.local.on("trigger", function (notification) {
            console.log('*** notification trigger ***');

            if (LocalNotificationsAPI.getPlatform() == "ios") {
                LocalNotificationsAPI.notificationModal(notification);
            }
        });

        //Fired when user clicks on a notification
        //iOS: A notification is only fired if the app is not in focus
        //Android: A notification is always fired.
        cordova.plugins.notification.local.on("click", function (notification) {
            console.log('*** notification click ***');
            LocalNotificationsAPI.navToPlugin(notification);
        });
    }
});
"use strict";

/**
 * Created by danielhindi on 9/14/16.
 */

var localStorageAPI = {
    _prefix: '_bfls_',
    setItem: function setItem(keyValue, callback) {
        if (!keyValue || !keyValue.key || !keyValue.value) callback(new Error("invalid parameters. Expected Key/Value object"));else {
            localStorage.setItem(localStorageAPI._prefix + keyValue.key, keyValue.value);
            callback(null, true);
        }
    },
    getItem: function getItem(key, callback) {

        if (key && key.key) key = key.key;

        if (!key || !callback) callback(new Error("invalid parameters. Expected Key and Callback"));else {
            var val = localStorage.getItem(localStorageAPI._prefix + key);
            callback(null, val);
        }
    },
    removeItem: function removeItem(key, callback) {

        if (key && key.key) key = key.key;

        if (!key || !callback) callback(new Error("invalid parameters. Expected Key and Callback"));else {
            localStorage.removeItem(localStorageAPI._prefix + key);
            callback(null, true);
        }
    }
};
"use strict";

var validator = {
    validatePassword: function validatePassword(password) {
        //8 char min, Capital and small, number and symbol
        if (!password || password.length < 8 || password.length > 60) return false;
        var hasUpperCase = /[A-Z]/.test(password);
        var hasLowerCase = /[a-z]/.test(password);
        var hasNumbers = /\d/.test(password);
        var hasNonalphas = /\W/.test(password);

        return hasUpperCase && hasLowerCase && hasNumbers && hasNonalphas;
    },
    passwordPattern: {
        test: function test(value) {
            return validator.validatePassword(value);
        }
    }
};
"use strict";

/**
 * Created by Ayman on 1/10/2018.
 */

function PushNotificationsAPI(context) {
    this.context = context;
}

PushNotificationsAPI.prototype = {
    ///params: {title, text, at, groupName, users, usersTags, queryString}
    schedule: function schedule(params, callback) {
        if (!params || !params.text || !params.title) {
            if (callback) callback('text or title is empty');
            return;
        }
        if (!this.context || !this.context.instanceId) {
            if (callback) callback('instanceId is null, unable to build groupID');
            return;
        }
        if (!params.at) params.at = new Date();
        if (!params.groupName) {
            params.groupName = '';
        }

        var data = {
            groupID: PushNotificationsAPI._getGroupID(this.context, params.groupName),
            users: params.users,
            userTags: params.userTags,
            title: params.title,
            message: params.text,
            sendAfter: params.at,
            source: "plugin",
            richMessage: params.inAppMessage || undefined
        };
        data.sourceId = window.appContext.currentApp.appId + "_" + this.context.instanceId + "_" + data.source;

        if (params.actionItem !== false) {
            if (params.actionItem) {
                data.actionItem = params.actionItem;
            } else {
                data.actionItem = {
                    title: 'View',
                    action: 'linkToApp',
                    instanceId: this.context.instanceId,
                    queryString: params.queryString
                };
            }
        }

        authAPI.getCurrentUser(function (err, user) {
            data.authCreatedBy = user && user._id ? user._id.toString() : null;

            bfUtils.http.post(window.siteConfig.endPoints.pushV2 + "/api/app/" + window.appContext.currentApp.appId + "/notification/", data).success(function (result) {
                if (callback) callback(null, result);
            }).error(function (data, status, headers, config) {
                if (callback) callback(data);
            });
        });
    },
    ///params: id
    cancel: function cancel(id, callback) {
        if (!id) {
            if (callback) callback('id is empty');
            return;
        }
        if (!this.context || !this.context.instanceId) {
            if (callback) callback('instanceId is null, unable to build groupID');
            return;
        }
        var data = {
            source: "plugin"
        };
        data.sourceId = window.appContext.currentApp.appId + "_" + this.context.instanceId + "_" + data.source;

        authAPI.getCurrentUser(function (err, user) {
            data.authCanceledBy = user && user._id ? user._id.toString() : null;

            bfUtils.http.post(window.siteConfig.endPoints.pushV2 + "/api/app/" + window.appContext.currentApp.appId + "/notification/" + id + '/cancel', data).success(function (result) {
                if (callback) callback(null, true);
            }).error(function (data, status, headers, config) {
                if (callback) callback(data);
            });
        });
    },
    ///params: {groupName}
    subscribe: function subscribe(params, callback) {
        if (!params) params = {};
        if (!params.groupName) params.groupName = '';
        if (!this.context || !this.context.instanceId) {
            if (callback) callback('instanceId is null, unable to build groupID');
            return;
        }
        var groupID = PushNotificationsAPI._getGroupID(this.context, params.groupName);
        PushNotificationsAPI._subscribe({ groupID: groupID }, callback);
    },
    ///params: {groupName}
    unsubscribe: function unsubscribe(params, callback) {
        if (!params) params = {};
        if (!params.groupName) params.groupName = '';
        if (!this.context || !this.context.instanceId) {
            if (callback) callback('instanceId is null, unable to build groupID');
            return;
        }
        var groupID = PushNotificationsAPI._getGroupID(this.context, params.groupName);
        PushNotificationsAPI._unsubscribe({ groupID: groupID }, callback);
    }
};

PushNotificationsAPI._getGroupID = function (context, groupName) {
    return window.appContext.currentApp.appId + "_" + context.instanceId + "_" + groupName;
};

PushNotificationsAPI._unsubscribe = function (params, callback) {
    if (!window.push || !window.push.deviceId || !window.push.platform) {
        if (callback) callback('Device not ready to get the deviceId');
        return;
    }
    if (!params) {
        params = {};
    }
    if (!params.groupID) {
        callback('groupID is not specified');
        return;
    }

    authAPI.getCurrentUser(function (err, user) {
        params.deviceID = push.deviceId;
        params.os = window.push.platform ? window.push.platform.toLowerCase() : '';
        params.authUserId = user && user._id ? user._id.toString() : null;

        bfUtils.http.post(window.siteConfig.endPoints.pushV2 + "/api/app/" + window.appContext.currentApp.appId + "/unsubscribe/", params).success(function (result) {
            if (callback) callback(null, true);
        }).error(function (data, status, headers, config) {
            if (callback) callback(data);
        });
    });
};

PushNotificationsAPI._subscribe = function (params, callback) {
    if (!window.push || !window.push.deviceId || !window.push.platform) {
        if (callback) callback('Device not ready to get the deviceId');
        return;
    }
    if (!params) {
        params = {};
    }
    if (!params.groupID) {
        params.groupID = '';
    }

    authAPI.getCurrentUser(function (err, user) {
        var pushSupportsFCM = typeof PushNotification !== "undefined" && typeof PushNotification.listChannels !== "undefined";
        var isFCM = device.platform && device.platform.toLowerCase() === "android" && pushSupportsFCM;

        params.deviceID = push.deviceId;
        params.os = window.push.platform ? window.push.platform.toLowerCase() : '';
        params.authUserId = user && user._id ? user._id.toString() : null;
        params.device = typeof device !== 'undefined' ? device : null;
        params.deliveryMethod = isFCM ? 'FCM' : null;

        var currentPushDeviceID = localStorage.getItem("currentPushDeviceID");
        if (currentPushDeviceID && currentPushDeviceID !== push.deviceId) {
            params.oldDeviceID = currentPushDeviceID;
        }

        bfUtils.http.post(window.siteConfig.endPoints.pushV2 + "/api/app/" + window.appContext.currentApp.appId + "/subscribe/", params).success(function (result) {
            localStorage.setItem("currentPushDeviceID", push.deviceId);
            if (callback) callback(null, true);
        }).error(function (data, status, headers, config) {
            if (callback) callback(data);
        });
    });
};

(function () {
    authAPI.onLogin(function () {
        setTimeout(function () {
            PushNotificationsAPI._subscribe();
        }, 2000);
    });
    authAPI.onLogout(function () {
        setTimeout(function () {
            PushNotificationsAPI._subscribe();
        }, 2000);
    });
})();
"use strict";

/**
 * Created by Ayman on 4/4/2018.
 */

function FirebaseAPI(context) {
    this.context = context;
}

FirebaseAPI.prototype = {
    createCustomToken: function createCustomToken(params, callback) {
        var self = this;

        function firebaseLogin(user) {
            FirebaseAPI._getUser({
                instanceId: self.context.instanceId,
                appId: window.appContext.currentApp.appId,
                integrationToken: params.integrationToken
            }, function (err, currentUser) {
                if (!currentUser || params && params.forceLogin) {
                    //call login api
                    bfUtils.http.post(window.siteConfig.endPoints.appHost + "/api/user/firebase/login", {
                        authUserId: user._id,
                        authAccessToken: user.accessToken,
                        pluginTypesToken: self.context.pluginId,
                        appId: window.appContext.currentApp.appId,
                        instanceId: self.context.instanceId,
                        integrationToken: params.integrationToken
                    }).success(function (result) {
                        FirebaseAPI._setUser({
                            instanceId: self.context.instanceId,
                            appId: window.appContext.currentApp.appId,
                            integrationToken: params.integrationToken
                        }, result);
                        if (callback) callback(null, result);
                    }).error(function (data, status, headers, config) {
                        if (status == 401 || status == 403) {
                            authAPI.logout();
                            authAPI.login({}, function (err, user) {
                                if (user) {
                                    firebaseLogin(user);
                                } else {
                                    if (callback) callback(null, null);
                                }
                            });
                        } else {
                            if (callback) callback(data);
                        }
                    });
                } else {
                    if (callback) callback(null, currentUser);
                }
            });
        }

        authAPI.getCurrentUser(function (err, user) {
            if (user) {
                firebaseLogin(user);
            } else {
                authAPI.login({}, function (err, user) {
                    if (user) {
                        firebaseLogin(user);
                    } else {
                        if (callback) callback(null, null);
                    }
                });
            }
        });
    }
};

(function () {
    //cache the custom user login per appId and instanceId for max 1 hour
    var users = {};

    FirebaseAPI._getUser = function (params, callback) {
        var key = params.appId + "_" + params.instanceId + "_" + params.integrationToken;
        var user = users[key];
        var prvHour = new Date();
        prvHour.setMinutes(prvHour.getMinutes() - 60);
        if (user && user.createdOn > prvHour) {
            callback(null, user.value);
        } else {
            users[key] = undefined;
            callback(null, null);
        }
    };
    FirebaseAPI._setUser = function (params, value) {
        var key = params.appId + "_" + params.instanceId + "_" + params.integrationToken;
        users[key] = {
            createdOn: new Date(),
            value: value
        };
    };

    authAPI.onLogout(function () {
        users = {};
    });
})();